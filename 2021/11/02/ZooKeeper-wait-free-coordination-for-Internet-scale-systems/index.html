<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>ZooKeeper-wait-free-coordination-for-Internet-scale-systems | Mr言的博客</title><meta name="description" content="本文是对谷歌论文：ZooKeeper: wait-free coordination for Internet-scale systems的笔记 Url:http:&#x2F;&#x2F;nil.csail.mit.edu&#x2F;6.824&#x2F;2020&#x2F;papers&#x2F;zookeeper.pdf  Abstract ZooKeeper希望创建一个简单，高性能的内核，用于在客户端构建更复杂的协调原语。 ZooKeeper借口可以"><meta name="keywords" content="分布式系统,文件系统"><meta name="author" content="严轶轩"><meta name="copyright" content="严轶轩"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://hm.baidu.com"/><link rel="dns-prefetch" href="https://hm.baidu.com"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="KMNZCFXyxopGAiX0"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="ZooKeeper-wait-free-coordination-for-Internet-scale-systems"><meta name="twitter:description" content="本文是对谷歌论文：ZooKeeper: wait-free coordination for Internet-scale systems的笔记 Url:http:&#x2F;&#x2F;nil.csail.mit.edu&#x2F;6.824&#x2F;2020&#x2F;papers&#x2F;zookeeper.pdf  Abstract ZooKeeper希望创建一个简单，高性能的内核，用于在客户端构建更复杂的协调原语。 ZooKeeper借口可以"><meta name="twitter:image" content="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/o3yatk.jpg"><meta property="og:type" content="article"><meta property="og:title" content="ZooKeeper-wait-free-coordination-for-Internet-scale-systems"><meta property="og:url" content="https://www.mryan.cool/2021/11/02/ZooKeeper-wait-free-coordination-for-Internet-scale-systems/"><meta property="og:site_name" content="Mr言的博客"><meta property="og:description" content="本文是对谷歌论文：ZooKeeper: wait-free coordination for Internet-scale systems的笔记 Url:http:&#x2F;&#x2F;nil.csail.mit.edu&#x2F;6.824&#x2F;2020&#x2F;papers&#x2F;zookeeper.pdf  Abstract ZooKeeper希望创建一个简单，高性能的内核，用于在客户端构建更复杂的协调原语。 ZooKeeper借口可以"><meta property="og:image" content="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/o3yatk.jpg"><meta property="article:published_time" content="2021-11-01T16:05:04.000Z"><meta property="article:modified_time" content="2021-11-01T16:12:01.535Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://www.mryan.cool/2021/11/02/ZooKeeper-wait-free-coordination-for-Internet-scale-systems/"><link rel="next" title="python依赖树--pipdeptree" href="https://www.mryan.cool/2021/10/14/python%E4%BE%9D%E8%B5%96%E6%A0%91-pipdeptree/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?c11dcf5678886a7b82be8df8aa725fcc";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="Mr言的博客" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://res.cloudinary.com/bravey/image/upload/v1588158174/avatar3.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">10</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">6</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关系</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#abstract"><span class="toc-number">1.</span> <span class="toc-text"> Abstract</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#introduction"><span class="toc-number">2.</span> <span class="toc-text"> Introduction</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%A1%E7%8C%AE"><span class="toc-number">2.1.</span> <span class="toc-text"> 贡献</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zookeeper%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.2.</span> <span class="toc-text"> ZooKeeper的服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD"><span class="toc-number">2.3.</span> <span class="toc-text"> 术语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%A6%82%E8%A7%88"><span class="toc-number">2.4.</span> <span class="toc-text"> 服务概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#clint-api"><span class="toc-number">2.5.</span> <span class="toc-text"> Clint api</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zookeeper%E7%9A%84%E4%BF%9D%E8%AF%81"><span class="toc-number">2.6.</span> <span class="toc-text"> zookeeper的保证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E8%AF%AD%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.7.</span> <span class="toc-text"> 元语示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"><span class="toc-number">2.7.1.</span> <span class="toc-text"> 配置管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E5%90%88"><span class="toc-number">2.7.2.</span> <span class="toc-text"> 汇合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E7%AE%A1%E7%90%86"><span class="toc-number">2.7.3.</span> <span class="toc-text"> 组管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%94%81"><span class="toc-number">2.7.4.</span> <span class="toc-text"> 简单锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E4%BB%8E%E4%BC%97%E6%95%88%E5%BA%94%E7%9A%84%E7%AE%80%E5%8D%95%E9%94%81"><span class="toc-number">2.7.5.</span> <span class="toc-text"> 没有从众效应的简单锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">2.7.6.</span> <span class="toc-text"> 读写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%87%8D%E5%B1%8F%E9%9A%9C"><span class="toc-number">2.7.7.</span> <span class="toc-text"> 双重屏障</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#zookeeper%E5%BA%94%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text"> zookeeper应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#fetching-service"><span class="toc-number">3.1.</span> <span class="toc-text"> Fetching service</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#katta"><span class="toc-number">3.2.</span> <span class="toc-text"> katta</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#yahoo-massage-broker"><span class="toc-number">3.3.</span> <span class="toc-text"> Yahoo! Massage Broker</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#zookeeper%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text"> ZooKeeper实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#request-processor"><span class="toc-number">4.1.</span> <span class="toc-text"> request processor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#atomic-broadcast"><span class="toc-number">4.2.</span> <span class="toc-text"> Atomic Broadcast</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#replicated-database"><span class="toc-number">4.3.</span> <span class="toc-text"> Replicated Database</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#client-server-interaction"><span class="toc-number">4.4.</span> <span class="toc-text"> client-server interaction</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#evaluation"><span class="toc-number">5.</span> <span class="toc-text"> Evaluation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">5.1.</span> <span class="toc-text"> 吞吐量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#related-work"><span class="toc-number">6.</span> <span class="toc-text"> related work</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/o3yatk.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Mr言的博客</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关系</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">ZooKeeper-wait-free-coordination-for-Internet-scale-systems</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-11-02 00:05:04"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2021-11-02</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-11-02 00:12:01"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-11-02</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">分布式系统</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>本文是对谷歌论文：ZooKeeper: wait-free coordination for Internet-scale systems的笔记</p>
<p>Url:<a target="_blank" rel="noopener" href="http://nil.csail.mit.edu/6.824/2020/papers/zookeeper.pdf">http://nil.csail.mit.edu/6.824/2020/papers/zookeeper.pdf</a></p>
<h1 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> Abstract</h1>
<p>ZooKeeper希望创建一个简单，高性能的内核，用于在客户端构建更复杂的协调原语。</p>
<p>ZooKeeper借口可以提供高性能服务实现。除了无等待之外，ZooKeeper保证每个client一个FIFO的请求队列，线性化所有改变ZooKeeper状态的请求。</p>
<h1 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h1>
<p>在设计ZooKeeper的API时，我们不再使用阻塞元语，比如锁。阻塞协调服务的原语可能会导致其他问题，包括缓慢或错误的客户端对更快的客户端的性能产生负面影响。如果服务进程请求依赖其他client的响应或者失败检测，实现起来会更加麻烦。因此，在Zookeeper中， 可以操作层次化的无等待数据对象，就像文件系统一样。ZooKeeper类似其他任何一个文件系统。</p>
<p>尽管无锁对性能和和错误容错很关键，但是处理协作还是不够，因此我们提供了事务的顺序保证。特别是，对client所有操作的FIFO顺序化以及将写串行化可以实现我们的服务，并且实现协作元语。</p>
<p>ZooKeeper由多个服务器组成，用复制来实现高性能和高可用性。高性能体现在可以让由大量进程组成的应用通过使用协作内核来管理各个层级的协作。我们可以通过简单的流水线架构来实现ZooKeeper，即使有大量请求未完成，仍然保持低延时。这样的架构自然允许来自client的操作以FIFO的顺序执行。保证FIFO client顺序，允许client去异步提交操作。通过异步操作，client可以在同一时刻有多个未完成的操作。该特性很关键，因为当一个client成为leader时，他必须管理元数据并相应更新他。如果没有多个未完成操作的可能性，初始化可能是秒级而不是亚秒级。</p>
<p>为了保证更新操作满足串行，实现了基于leader的原子传播协议，叫做Zab。ZooKeeper应用的典型负载主要是读操作，因此渴望去扩展读吞吐量。在ZooKeeper中，服务器在本地处理读操作，并不适用Zab来排序。</p>
<p>在client端缓存数据也是一个提高读性能的关键技术，比如缓存leader。ZooKeeper使用监听机制，让client来缓存数据而不是直接管理client的数据。通过该机制，client可以对一个给定数据对象进行监听，当更新时，收到通知。Chubby直接管理client缓存。它阻止更新来验证缓存正在更改的数据的所有客户端的缓存。如果client其中一个运行速度慢或者出现异常，更新会慢下来。Chubby用租贷来阻止Client异常来无限阻止系统。然而租约只限制了缓慢或错误的客户端的影响，而ZooKeeper监听则完全避免了这个问题。</p>
<h2 id="贡献"><a class="markdownIt-Anchor" href="#贡献"></a> 贡献</h2>
<ol>
<li>协作内核：提出了一种在分布式系统中使用的具有宽松一致性保证的无等待协调服务</li>
<li>协作方法：如何构建更高级的协作元语</li>
<li>经验与协调</li>
</ol>
<h2 id="zookeeper的服务"><a class="markdownIt-Anchor" href="#zookeeper的服务"></a> ZooKeeper的服务</h2>
<p>client通过zookeeper库提供的API来发送请求，除了通过client api来暴露zookeeper服务接口，client库也会管理client和zookeeper server的网络连接。</p>
<h2 id="术语"><a class="markdownIt-Anchor" href="#术语"></a> 术语</h2>
<ol>
<li>client： ZooKeeper服务的使用者</li>
<li>server：提供服务的进程</li>
<li>znode：zookeeper数据中的内存数据节点，被组织在称为数据树的分层名称空间中。</li>
</ol>
<p>client在连接zookeeper时会创建一个session和在通过session handle发送请求</p>
<h2 id="服务概览"><a class="markdownIt-Anchor" href="#服务概览"></a> 服务概览</h2>
<p>ZooKeerper提供给client一系列抽象的数据节点（znode），通过分层命名空间来组织。分层中的znode是一个数据对象，client通过ZooKeeper API来控制。分类空间多用于文件系统，是一个组织数据对象的好方法。因为用户可以使用该抽象，可以更好的管理应用程序的元数据。对于一个znode，我们使用标准的unit 文件路径来标识</p>
<p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/5xoahH.png" alt="" /></p>
<p>client可以创建两种类型的znode</p>
<ol>
<li>regular：client显式创建和删除znode</li>
<li>ephemeral：client创建该znode，要么显式删除，要么等到session结束时系统自动删除</li>
</ol>
<p>当创建一个znode时，client可以设置一个连续的标记。使用顺序标记集创建的节点在其名称后附加一个单调递增的计数器的值。如果n是一个新的znode，p是父znode，n则永远不会小于在p节点下创建的znode的值。</p>
<p>ZooKeeper实现了watches，允许client及时接收更改通知，而不需要轮询。当client发出一个设置了监视标志的读操作时，除非服务器承诺在返回的信息发生更改时通知客户端，否则操作将正常完成。监听和session联系在一起的一次性触发器，一旦触发或者session结束，触发器就注销。监听只是表明改变发生，但是不会提供任何操作。比如一个client发送请求getData(&quot;/foo&quot; , true)，在“/foo“改变两次之前，client会触发watch event告诉他foo的数据已经改变。session event，比如连接丢失也会发送一个watch callback给client，以便告诉他watch event可能延迟。</p>
<p>**数据模型：**zookeeper的数据模型本质上是一个带有简化API的文件系统，只进行数据的读和写，或者一个带有层次空间的key的key/value表格。层次命名空间对于为不同应用程序的名称空间定位子树和设置对这些子树的访问权限非常有用。</p>
<p>不像文件系统的文件，znode不是用来存储通用数据的。znode映射成client应用程序的抽象，通常存储用于协调目的的元数据。比如figure1 ，应用程序1（/app1）和应用程序2（/app2）。app1的子树实现了一个简单的组成员协议:每个client进程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>在/app1下创建一个znode<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，只要进程一直运行，znode就会一直存在。</p>
<p>尽管znode设计出来不是为了数据存储，但zookeeper允许client去存储一些信息，比如用于分布式计算的元数据或者配置文件。比如，在基于leader的应用程序中，让server知道当前leader是谁很有用。为了实现这一功能，我们可以将当前leader写在znode中。znode还将元数据与时间戳和版本控制器相关联，从而允许client去跟踪znode的改变，根据znode的版本执行更新。</p>
<p>**session：**client连接zookeeper会出初始化一个session。session有一个timeout。zookeeper如果没有通过session在timeout时间段内收到任何信息，会认为client出现故障。当client显式关闭session handle或者zookeeper发现client出现故障，session会自动结束。通过session，client可以观察一系列可以反应执行操作的状态改变。session可以当client在zookeeper集群中从一个server移动到另一个server，因此实现了zookeeper server的持久化。</p>
<h2 id="clint-api"><a class="markdownIt-Anchor" href="#clint-api"></a> Clint api</h2>
<ol>
<li>Create(path , data , flags):在path创建一个znode，并且在znode中存储data，返回znode的名字。flags可以让client选择znode的种类----regular，ephemeral，并设置连续标志</li>
<li>delete(path ,version)：如果znode是期望的verson，删除path路径的znode</li>
<li>exists(path ,watch)：如果path的znode存在，则返回true，否则返回false。watch标识可以让client去给znode设置一个watch</li>
<li>getData(path , watch)：返回znode的data和元数据，比如版本信息等。watch标识和exists一样。除非znode不存在，否则zookeeper一定会给znode设置watch</li>
<li>setData(path , data ,version)：如果versino是znode 的版本号，则将data[]写入znode</li>
<li>getChildren(path , watch)：返回znode的孩子的名字</li>
<li>sync(path)：在操作开始时等待所有挂起的更新，以传播到客户端连接的服务器。该路径当前被忽略</li>
</ol>
<p>所有的方法都有同步和异步的版本。当执行单个zookeeper操作，并且没有并发任务去执行时，可以使用同步，他会让zookeerer调用或者阻塞。异步API可以让应用程序控制多个zookeeper操作并且同步运行。ZooKeeper客户端保证按顺序调用返回每个操作的相应回调。</p>
<p>zookeeper并不会使用session handle去访问znode。每个请求都会包含正在执行操作的znode的完整路径。该操作不仅仅简化了api(没有open()和close()操作)，而且不需要server去维持额外的状态。(否则可能需要维护handle的状态)</p>
<p>每个更新方法都带有一个版本号，这样使得条件更新成为可能。如果znode真实的版本号不符合期望的版本号，更新会失败并出现版本error。如果版本号是-1，则不会进行版本检查</p>
<h2 id="zookeeper的保证"><a class="markdownIt-Anchor" href="#zookeeper的保证"></a> zookeeper的保证</h2>
<ol>
<li>串行写：更新zookeeper状态的请求都会被串行化并且遵照优先权</li>
<li>FIFO读：client的读请求会按照请求发送的顺序执行</li>
</ol>
<p>zookeeper的串行并不是原始的串行，而是A-linearizability（异步串行）。在最初串行的定义中，一个client只能有悬挂的操作。在zookeeper中，允许多个悬挂的操作，zookeeper会按序选择来保证没有client的悬挂操作有特殊性，从而实现先进先出。</p>
<p>线性化对象的结果也适用于A-线性化，因为A-线性化也满足线性化。仅仅只有更新请求会被A-线性化，zookeeper在每个备份server本地处理读请求，这使得服务被加入到系统中实现现行增长。</p>
<p>为了理解这两个保证如何实现，想象一个场景：一个系统由一系列进程组成，选择一个进程去指挥worker进程。当一个新leader掌控系统时，他必须改变一系列配置参数，并且更新完需要通知其他的进程，我们因此提出两个需求</p>
<ol>
<li>当leader开始更新时，我们不希望其他进程使用正在更新的配置，即仍然使用过去的配置文件</li>
<li>如果leader在配置更新前就死亡，我们不希望其他进程去用这个没有更新完的配置文件。</li>
</ol>
<p>一般的分布式锁，比如chubby提供的，可以实现第一个需求，但是无法实现第二个需求。在zookeeper中，新leader可以委托一个path作为ready znode，其他的进程仅仅当该znode存在时，才可以使用配置文件。新leader通过删除ready znode，更改配置znode，创建ready znode来更新配置文件。所有这些更改都可以通过管道处理并异步发出，以快速更新配置状态。尽管更改操作的延迟大约是2毫秒，但如果一个新的leader必须更新5000个不同的znode，那么如果请求一个接一个地发出，则需要10秒。但是通过异步发出请求会使得延时小于1秒。由于排序的保证，如果一个进程看到了ready znode，他一定可以知道新leader完成了所有的更新操作。如果一个新leader在ready znode创建之前死了，其他的进程知道配置文件还没有更新完，于是则不会使用。</p>
<p><strong>上述策略还存在一个问题，如果一个进程在新leader开始更新之前看到了ready znode，并且在leader更新znode的时候读取配置文件会发生什么？</strong></p>
<p>这个问题可以通过通知的排序保证来解决。如果client正在监视更改，则客户端将在看到更改后系统的新状态之前看到通知事件。因此，如果读取ready znode的进程请求通知对该znode的更改，那么它将看到一个通知，在它可以读取任何新配置之前通知客户机该更改。</p>
<p>zookeeper保证活力和持久性</p>
<ol>
<li>只有绝大多数server可以通信的时候，服务才可用</li>
<li>任何一个成功的操作都会被持久化。</li>
</ol>
<h2 id="元语示例"><a class="markdownIt-Anchor" href="#元语示例"></a> 元语示例</h2>
<p>如何使用zookeeper的api实现更强大的元语。 ZooKeeper服务对这些更强大的原语一无所知，因为它们完全是在客户端通过ZooKeeper客户端API实现的。基本的元语比如组成员和配置管理是无等待的。其他的，比如回合，client需要等待事件。尽管zookeeper无等待，但是我们可以通过zookeeper实现有效的阻塞元语。zookeeper的顺序保证允许对系统状态进行推理，watch机制允许有效的等待。</p>
<h3 id="配置管理"><a class="markdownIt-Anchor" href="#配置管理"></a> 配置管理</h3>
<p>zookeeper可以用来在分布式应用中动态管理配置。配置以最简单的形式存储在znode中,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>C</mi></msub></mrow><annotation encoding="application/x-tex">z_C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。进程会通过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>C</mi></msub></mrow><annotation encoding="application/x-tex">z_C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的完整路径来访问。启动进场会通过设置watch标志为true来读取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>C</mi></msub></mrow><annotation encoding="application/x-tex">z_C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的配置。如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>C</mi></msub></mrow><annotation encoding="application/x-tex">z_C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的配置改变，进程会收到通知，读取新的配置，再次设置watch标志为true。</p>
<p>在该策略中，和其他大多数一样使用watch机制，watches用来保证进程收到最新的信息。</p>
<p>例如，如果一个监视<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">z_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的进程被通知<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">z_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>发生了变化，并且在它发出对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>C</mi></msub></mrow><annotation encoding="application/x-tex">z_C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的读取之前，会收到更新通知，在收到更新通知之前，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>C</mi></msub></mrow><annotation encoding="application/x-tex">z_C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>又收到了三个更新，进程不会收到三个更新通知。但是这并不影响进程的行为，因为这三个时间只是简单的通知进程他已经知道的事----<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">z_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的信息已经过期了。</p>
<h3 id="汇合"><a class="markdownIt-Anchor" href="#汇合"></a> 汇合</h3>
<p>在分布式系统中，最终的系统配置并不是很清楚。例如，client可能希望启动一个master进程和几个worker进程，但启动进程是由调度程序完成的，因此客户机无法提前知道它可以提供给工作进程以连接到主进程的地址和端口等信息。</p>
<p>我们可以使用汇合znode来解决，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">z_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，是一个由client创建的znode。client传递<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">z_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的完成路径作为master和worker进程的启动参数。当master进程启动时，他会将地址和端口填入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">z_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中，当worker进程启动时，会读取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">z_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,同时设置watch为true。如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">z_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>仍然没有被填满，worker会等待直到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">z_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>更新时收到通知。如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">z_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是一个ephemeral node，master和worker进程可以鉴定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">z_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是否被删除来判断是否结束自身。</p>
<h3 id="组管理"><a class="markdownIt-Anchor" href="#组管理"></a> 组管理</h3>
<p>可以利用ephemeral node来实现组管理。具体来说，我们可以使用ehpemeral node来观察创建node的状态。</p>
<p>最先为讨一个znode,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">z_g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>去代表一个组。当组的一个进程启动时，会在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">z_g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>下创建一个znode。如果每个进程都有一个标识名字或者一个标识符，那个这个可以作为znode的名字，否则进程创建一个带有SEQUENTIAL 标志的znode去维护名字的分配。进程可以将子进程的信息放入子znode中，比如进程的address，port等</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">z_g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的子znode正常创建后，不需要做什么其他的，如果进程失败或者结束，表示进程的znode会自动移除(因为进程结果，进程和znode的session会消失，系统会自动移除znode)。</p>
<p>进程可以通过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">z_g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>来了解组的信息。如果进程希望监视组成员关系的变化，则进程可以将监视标志设置为true，并在收到更改通知时刷新组信息(随时将监视标志设置为true)。</p>
<h3 id="简单锁"><a class="markdownIt-Anchor" href="#简单锁"></a> 简单锁</h3>
<p>尽管zookeeper没有锁服务，但是可以用来实现锁。 使用ZooKeeper的应用程序通常使用定制的同步原语。</p>
<p>最简单的锁实现使用“锁文件”。锁由znode表示，为了得到锁，client尝试用EPHEMERAL标志创建指定的znode。如果创建成功，client拿到锁，否则，client可以用watch标志来读取znode，如果znode死亡，会通知该client。当进程死亡或者显式删除znode，client会释放锁。其他正在等待锁的client在观察到znode被删除后，会再次尝试获取锁</p>
<p>虽然这个简单的锁定协议可以工作，但它确实存在一些问题。首先，它受到从众效应的影响。如果有很多客户端在等待获取锁，那么当锁被释放时，即使只有一个客户端可以获取锁，它们也会竞相获取锁。其次，它只实现排他锁。</p>
<h3 id="没有从众效应的简单锁"><a class="markdownIt-Anchor" href="#没有从众效应的简单锁"></a> 没有从众效应的简单锁</h3>
<p>定义一个锁znode l来实现</p>
<p>我们直观地排列所有请求锁的client，每个client按照请求到达的顺序获得锁。希望获得锁的client做如下操作</p>
<p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/vjpLvG.png" alt="" /></p>
<p>lock命令中，使用SEQUENTIAL表示来对请求锁的client进行排序。第3行，如果client的znode有最小的序号，client会得到锁。否则，客户端将在该客户端的znode之前等待删除具有锁或将接收锁的znode。通过监听之前的一个znode，我们可以避免从众效应，只是在一个锁释放或者锁请求丢弃时唤醒一个进程。一旦被监听的znode离开，client必须检查他现在是否占有锁（之前的锁请求可能已经被放弃，但有一个序号更低的znode仍在等待或者持有锁）。</p>
<p>释放锁仅仅是删除znode，因为znode设置为EPHEMERAL，崩溃的进程会自动清楚锁请求或者释放持有的锁。</p>
<p>总结：这种锁有如下优点</p>
<ol>
<li>znode移除仅仅会唤醒一个client，因为每个znode仅仅监听前一个client，不必担心从众效应</li>
<li>没有轮训或者超时</li>
<li>通过该方式，我们可以查看zookeeper的数据来锁的数量，断锁和调试锁的问题</li>
</ol>
<h3 id="读写锁"><a class="markdownIt-Anchor" href="#读写锁"></a> 读写锁</h3>
<p>为了实现读/写锁，我们稍微改变锁过程，让读锁和写锁过程分开。解锁过程如上</p>
<p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/F56JgK.png" alt="" /></p>
<p>可能出现从众效应，如果多个读锁之前的写锁释放，多个读锁会同时请求获取锁。</p>
<h3 id="双重屏障"><a class="markdownIt-Anchor" href="#双重屏障"></a> 双重屏障</h3>
<p>双重屏障可以让client去同步计算的开始和结束。</p>
<p>当足够多的进程(由屏障阈值定义)加入到屏障中，进程开始计算，一旦结束就离开屏障。我们用znode来表示屏障，叫做b，每个进程p都会在b下注册，创建一个b的子znode。</p>
<p>当b的子znode数目超过barrier阈值时，进程可以进入barrier。当所有进程都删除了他们的子进程，进程可以离开屏障。</p>
<h1 id="zookeeper应用"><a class="markdownIt-Anchor" href="#zookeeper应用"></a> zookeeper应用</h1>
<h2 id="fetching-service"><a class="markdownIt-Anchor" href="#fetching-service"></a> Fetching service</h2>
<p>爬虫是搜索引擎的重要部分，雅虎会爬取上亿页面。为了效率，会有一个master进程来命令爬取页面的进程。</p>
<p>master进程提供爬取的配置文件，fetcher进程写状态和健康信息。</p>
<p>使用zookeeper作为FS的最大优点是保证master从失败中恢复，就算失败，也保证其可用性，将client和server解偶，根据读取zookeeper的状态信息来将请求重定向健康的server中</p>
<h2 id="katta"><a class="markdownIt-Anchor" href="#katta"></a> katta</h2>
<p>katta是使用zookeeper的一个分布式索引器。katta使用切片划分索引工作。</p>
<p>master server将切片分给slave和track进程。slave可能失败，所以当slave失败时，master必须重新分配负载。master也可能失败，所以server必须做好接管的准备。katta使用zookeeper去跟踪slave server和master的状态(使用group membership)，使用zookeeper去处理master失败(leader election)。Katta还使用ZooKeeper来跟踪和传播分片分配给slave(configuration management)。</p>
<h2 id="yahoo-massage-broker"><a class="markdownIt-Anchor" href="#yahoo-massage-broker"></a> Yahoo! Massage Broker</h2>
<p>YMB是一个分布式订阅发布系统。该系统管理着数千个主题，客户可以向这些主题发送消息，也可以从这些主题接收消息，这些主题分布在一系列服务器上，每个主题都使用主备份方案进行复制，该方案确保将消息复制到两台机器，以确保可靠的消息传递。组成YMB的服务器使用无共享的分布式架构，这使得协调对于正确的操作至关重要/。</p>
<p>YMB使用zookeeper来管理分布式主题(配置文件元数据)，处理系统机器的失败(failure detection and group membership)，控制系统操作。</p>
<p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/dzWOFv.png" alt="" /></p>
<p>每个broker domain都有一个znode，该znode对于组成YMB服务的每个活动服务器都有一个临时znode。每个YMB server都会创建一个带有负载和状态信息的ephemeral znode在nodes下面，并通过zookeeper提供group membership 和 状态信息。shutdown和migration_prohibited被所有server监听，允许YMB的集中管理。topics目录是由YMB管理的znode，里面是每个主题。这些主题znode也有子znode。表示主题的首要服务器和备份服务器以及该主题的订阅者。primate和backup server znode不仅允许server去发现管理该主题的server，并且还管理leader election和server crashes</p>
<h1 id="zookeeper实现"><a class="markdownIt-Anchor" href="#zookeeper实现"></a> ZooKeeper实现</h1>
<p>zookeeper通过在每个server备份zookeeper数据来实现高可用性。</p>
<p>假设server崩溃，并且会在之后恢复。</p>
<p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/taB8Px.png" alt="" /></p>
<p>如图，在收到一个请求后，server为执行做好准备（request processor）。如果请求需要多个server的协同（write request），需要用到一个同意协议（原子传播的一种实现），最终server提交修改到 zookeeper完全备份了所有server的数据库中。在read request情况下，server仅仅读取本地数据库的状态，并且生成一个response。</p>
<p>备份数据库是包含整个数据树的内存数据库，每个znode默认最大存储1MB的数据，但是这个最大值可以在特定情况下根据配置参数来修改。</p>
<p>为了可恢复行，zookeeper会尽快将更新记录到磁盘中，并且在数据写入内存之前，强制先将数据写入磁盘。实际上，zookeeper实现了提交操作的重放日志(预写日志)，并且定期生成内存数据库的快照。</p>
<p>每个zookeeper server服务client。client连接一个server来提交request。对于read request被每个server的数据库的本地副本服务，对于会改变服务状态的request，比如write request，会通过aggrement protocol来完成。</p>
<p>在agreement protocol中，write request会首先提交到leader，剩下的zookeeper server成为follower，接受来自leader的消息更新提案，并统一状态改变，</p>
<h2 id="request-processor"><a class="markdownIt-Anchor" href="#request-processor"></a> request processor</h2>
<p>由于消息传递层是原子的，所以我们保证本地副本永远不会分离，尽管在任何时间点，一些服务器可能比其他服务器接受更多的事务。不像client发送的request，事务是等幂的。当leader接受了一个write request，会计算如果执行该操作后系统的状态，并且将事务转换成一个得到了新状态的新事务。因为可能存在尚未应用到数据库的未执行事务，因此必须计算未来的状态。</p>
<p>比如，当一个client执行setData()，request的版本号满足正在更新的znode的未来版本号，服务会产生一个包含了新数据，新版本号和更新时间戳的setDataTXN。如果出现error，比如版本号不匹配或者将要更新的znode不存在，errorTXN则会产生。</p>
<h2 id="atomic-broadcast"><a class="markdownIt-Anchor" href="#atomic-broadcast"></a> Atomic Broadcast</h2>
<p>所有更新zookeeper状态的请求都会提交到leader。leader执行request，并且将变更通过Zab广播给zookeeper状态。当接受了request请求的server交付了状态变更后，会给client响应。Zab默认会使用简单多数判定来决定提案，所以Zab和zookeeper只有在大多数server都运行正常的时候工作（因此2f+1个server能容忍f个异常）。</p>
<p>为了实现高吞吐量，zookeeper尝试让request进程通道保持满的状态。可能在处理管道的不同部分有上千个request。因为状态变更依赖于先前状态，Zab提供了比平常的原子广播更健壮的顺序保证。更具体地说，Zab保证一个leader广播的状态变更按照它们发出的顺序传送，并且在它广播自己的状态变更之前，前leader的所有状态变更都要传送给一个已建立的ledaer。</p>
<p>有一些细节可以简化我们的视线，并且提高效率。使用TCP作为传输，因此消息顺序由网络来维护，这样让我们简化我们的实现。</p>
<p>使用Zab选择的leader作为zookeeper的leader，因此创建事务的进程也会发布事务。使用日志去跟踪提案，作为内存数据库的预写日志，这样不用将操作写入磁盘两次。</p>
<p>在正常的操作期间，Zab会按序一次性提交所有的操作，但是Zab不会记录每次提交记录的id，所以Zab可能在恢复期间传递操作。因为我们使用的是幂等事务，多次提交是可以接受的，只要他们按序提交。事实上，ZooKeeper要求Zab至少重新交付上次快照开始之后交付的所有消息。</p>
<h2 id="replicated-database"><a class="markdownIt-Anchor" href="#replicated-database"></a> Replicated Database</h2>
<p>每个副本在内存中都有zookeeper状态的副本。当zookeeper server从崩溃中恢复，它需要恢复到这个内部状态。 在运行服务器一段时间后，重播所有传递的消息以恢复状态将花费令人望而退却的时间，所以ZooKeeper使用定期快照，并且仅仅要求上一个快照之后的重播。</p>
<p>zookeeper的快照称为<strong>fuzzy snapshot</strong>，因为在快照期间不会锁定zookeeper的状态，因此，我们首先定期对树进行深度扫描，以原子方式读取每个znode的数据和元数据，并将它们写入磁盘。由于产生的fuzzy snapshot可能应用了快照生成期间交付的状态更改的某个子集，因此结果可能不对应于ZooKeeper在任何时间点的状态。然而，zookeeper的状态变更是幂等的，只要保证状态变更按序即可。</p>
<h2 id="client-server-interaction"><a class="markdownIt-Anchor" href="#client-server-interaction"></a> client-server interaction</h2>
<p>当server处理一个write request时，它还发送和清除与该更新对应的任何watch相关的通知。server按序处理write request，但是不会并发处理write和read request。这保证了通知的严格连续性。server在本地处理通知，只有和client连接的server会跟踪和触发client的通知。</p>
<p>read request在每个server本地处理。每个read request被处理后被标记为zxid，zxid对应server响应的最后一个事务。zxid定义了read request相对于write request的偏序。通过在本地处理read request，可以得到性能上的提升（因为没有磁盘IO）。</p>
<p>使用快速读取的一个缺点是不能保证读取操作的优先顺序。即，一个read操作可能返回一个过期的数据，尽管该znode的更新请求提交完成。</p>
<p>并不是所有的应用都需要优先顺序，但对于一些需要优先数据的应用，我们提供了sync。这个原语是异步执行的，在对它的本地副本进行所有未决的写操作之后，由leader命令执行。为了保证给定的read操作返回最新更新的值，client调用sync再读取数据。</p>
<p>客户端操作的FIFO顺序保证以及同步的全局保证使读操作的结果能够反映sync发出之前发生的任何更改。</p>
<p>zookeeper server按照FIFO顺序处理request。response包括zxid。 即使在没有活动的间隔期间，心跳消息也包括client连接到的server看到的最后一个zxid。如果client连接到一个新的server，新的server通过比较zxid来保证他的zookeeper数据试图和client的视图一样近。</p>
<p>如果client有一个比serve更新的视图，server不会重新建立session，直到视图一致。client保证能够找到另一个server，该server有系统的最近视图，因为client只看到已备份到大多数ZooKeeper server的更改。这种行为对于保证耐久性非常重要</p>
<p>为了检查client session的失败，zookeeper使用timeout。如果server在timeout内没有收到任何来自client session的消息，则判断sesion出错。如果client发送请求足够频繁，则不需要发送其他消息。否则，client需要在低活动期间发送心跳检测。如果client不能和server联系来发送request或者心跳检测，他会连接到另一台server去重新建立连接。为了防止session超时，zookeeper client库在会话空闲s/ 3ms后发送一个心跳，如果会话在2s/ 3ms内没有收到server的消息，则切换到新的server，其中s是会话超时时间，单位为毫秒。</p>
<h1 id="evaluation"><a class="markdownIt-Anchor" href="#evaluation"></a> Evaluation</h1>
<p>在50台服务器的集群上测试。每台server配备1个Xeon双核2.1GHz处理器、4GB内存、千兆以太网和2个SATA硬盘。我们将下面的讨论分为两部分:请求的吞吐量和延迟</p>
<h2 id="吞吐量"><a class="markdownIt-Anchor" href="#吞吐量"></a> 吞吐量</h2>
<p>为了评估我们的系统，我们在系统饱和时测试吞吐量，以及不同注入失败时吞吐量的变化。我们改变组成zookeeper server的数目，但是使得client的数目一致。为了模拟大型client，使用35个机器来模拟250个client。</p>
<p>用java实现zookeeper server，用java和c实现zookeeper client。对于这些实验，我们使用Java服务器配置到一个专用磁盘并在另一个磁盘上拍摄快照</p>
<p>测试client使用java的异步api，每个client都有至少100个悬挂request。每个请求都包括读操作或者1K数据的写操作。我们不展示其他操作的基准测试，因为所有修改状态的操作的性能大致相同，而非状态修改操作(不包括同步)的性能大致相同。 client每300ms发送完成操作的数量计数，我们每6s采样一次。为了防止内存溢出，server限制系统中并发请求的数量。ZooKeeper使用请求节流来防止server过载。在这些实验中，我们配置了ZooKeeper server，使其最大处理总数为2000个请求</p>
<p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/c2FLW3.png" alt="" /></p>
<p>在图5中，当我们改变读请求和写请求的比率时，我们显示了吞吐量，每条曲线对应于提供ZooKeeper服务的不同数量的服务器。表1显示了读取负载的极端值。读吞吐量比写吞吐量高，因为读不使用原子广播。从图中还可以看出，服务器的数量也会对广播协议的性能产生负面影响。从这些图中，我们可以观察到系统中服务器的数量不仅会影响服务可以处理的故障数量，而且还会影响系统中服务器的数量。</p>
<p>有两个原因导致write request耗时比read request更久。</p>
<ol>
<li>write request必须经过原子广播，需要额外的处理，增加了请求延时</li>
<li>Server必须确保在向leader发送确认之前，事务被记录到非易失性存储中。原则上这个要求很苛刻，但对于我们的生产系统，我们用性能换取可靠性，因为ZooKeeper构成了应用的基本事实。</li>
</ol>
<p>使用更多的server，就必须可以容错。我们通过将ZooKeeper数据划分到多个ZooKeeper集成中来提高写吞吐量</p>
<p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/PyFCXN.png" alt="" /></p>
<p>ZooKeeper能够通过在组成服务端的服务器上分配负载来实现如此高的吞吐量。因为宽一致性保证，因此可以均衡负载。图6显示了如果我们不做均衡负载，将所有的client都连接给leader会出什么什么情况。正如预期的那样，对于以读为主的工作负载，吞吐量要低得多，但即使对于以写为主的工作负载，吞吐量也要低得多。由服务客户端造成的额外CPU和网络负载影响了领导协调建议广播的能力，这反过来又反过来影响了整体的写性能。</p>
<p>原子广播协议完成了系统的大部分工作，因此比其他组件更限制了Zoo- Keeper的性能。</p>
<p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/qnMihF.png" alt="" /></p>
<p>图7显示了原子广播的吞吐量。为了对其性能进行基准测试，我们通过直接在leader上生成事务来模拟客户端，因此没有客户端连接或客户端请求和应答，在最大吞吐量时，原子广播称为cpu的阻碍。理论上图7应该对应zookeeper 100%的写的性能，然而zookeeper client沟通，ACL检查，请求事务版本都需要CPU。CPU的争用使得ZooKeeper的吞吐量大大低于原子广播组件。因为Zoo- Keeper是一个关键的产品组件，到目前为止，我们对ZooKeeper的开发重点一直是正确性和健壮性。通过消除额外的副本、相同对象的多重序列化、更有效的内部数据结构等，有很多机会可以显著提高性能。</p>
<p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/np5APp.png" alt="" /></p>
<p>为了现实系统多次出现故障，我们运行了一个由五台server组成的zookeeper。我们运行了与之前相同的饱和基准测试，但这次我们将写入百分比保持在30%，这是我们预期工作负载的保守比率。我们定期终止一些服务器进程。图8显示了随时间变化的系统吞吐量。图中标注的事件如下:</p>
<ol>
<li>follower的失败和恢复</li>
<li>不同的follower的失败和恢复</li>
<li>leader的失败</li>
<li>两个follower失败，然后第三个恢复</li>
<li>leader失败</li>
<li>leader恢复</li>
</ol>
<p>从这个图表中有一些重要的观察结果。首先，如果追随者失败并快速恢复，那么ZooKeeper能够维持高吞吐量，尽管失败。单个follower的故障并不会阻止服务器形成仲裁，只会减少服务器在故障前处理的读请求份额的吞吐量。 其次，我们的领袖选举算法能够快速恢复，以防止吞吐量大幅下降。</p>
<p>在我们的观察中，zookeeper不到200ms就可以选举一个新的leader。因此，尽管server停止服务请求的时间只有几分之一秒，但由于我们的采样周期(以秒为数量级)，我们不会观察到吞吐量为零。其次，即使follower花很长时间去恢复，zookeeper一旦再次处理request， 仍然可以提高吞吐量。在事件1、2和4之后我们没有恢复到全部吞吐量级别的一个原因是，client只有在与follower的连接中断时才切换follower。因此，在事件4之后，client不会重新分配自己，直到leader在事件3和事件5失败。在实践中，随着client的来来去去，这种不平衡会随着时间的推移而自行消除。</p>
<h1 id="related-work"><a class="markdownIt-Anchor" href="#related-work"></a> related work</h1>
<p>ZooKeeper的目标是提供一种解决分布式应用中协调进程问题的服务。为了实现这个目标，它的设计使用了以前的协调服务、容错系统、分布式算法和文件系统的思想。</p>
<p>我们并不是第一个提出一个用于协调分布式应用的系统的人。一些早期的系统提出了一种分布式锁服务，用于事务性应用程序，以及用于在计算机集群[19]中共享信息。最近，Chubby提出了一个系统来管理分布式应用程序的咨询。chubby和zookeeper有几个共同的目标。它还具有一个类似文件系统的接口，并使用协议协议来保证副本的一致性。但是，ZooKeeper不是锁服务。客户端可以使用它来实现。不同意chubby，zookeeper允许client去连接所有的zookeeper server，不仅仅是leaer。zookeeper client可以使用本地备份来存储数据和管理watch，因为一致性模型比chubby更宽松。这可以让zookeeper提供更高的性能，允许备份使得zookeeper有更广泛的使用。</p>
<p>文献中已经提出了容错系统，其目标是缓解构建容错分布式应用程序的问题。 ISIS系统将抽象的类型规范转换为容错的分布式对象，从而使容错机制对用户透明。Horus和Ensemble是由ISIS演化而来的系统。ZooKeeper支持ISIS虚拟同步的概念。最后，Totem在一个利用局域网络的硬件广播的体系结构中保证了消息传递的总顺序。Zoo- Keeper与各种各样的网络拓扑结构一起工作，这促使我们在服务器进程之间依赖TCP连接，而不是假设任何特殊的拓扑结构或硬件特性。我们也不公开任何在ZooKeeper内部使用的集成通信。</p>
<p>构建容错服务的一项重要技术是状态机复制，而Paxos是一种算法，能够有效地实现异步系统的复制状态机。我们使用算法来分享paxos的一些特征，但这将达成共识所需的事务日志和数据树恢复所需的预写日志结合在一起，从而实现高效的实现。</p>
<p>ZooKeeper类似于一个小文件系统，但它只提供了文件系统操作的一小部分，并添加了大多数文件系统中不存在的功能，如排序保证和条件写。然而，ZooKeeper watch在本质上与AFS的缓存回调相似</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">严轶轩</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.mryan.cool/2021/11/02/ZooKeeper-wait-free-coordination-for-Internet-scale-systems/">https://www.mryan.cool/2021/11/02/ZooKeeper-wait-free-coordination-for-Internet-scale-systems/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.mryan.cool" target="_blank">Mr言的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">分布式系统</a><a class="post-meta__tags" href="/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">文件系统</a></div><div class="post_share"><div class="social-share" data-image="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/o3yatk.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2021/10/14/python%E4%BE%9D%E8%B5%96%E6%A0%91-pipdeptree/"><img class="next_cover" src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/frp7ZH.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">python依赖树--pipdeptree</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/09/02/In-Search-of-an-Understandable-Consensus-Algorithm-Extended-Version/" title="In Search of an Understandable Consensus Algorithm(Extended Version)"><img class="relatedPosts_cover" src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/dZ4ECE.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-09-02</div><div class="relatedPosts_title">In Search of an Understandable Consensus Algorithm(Extended Version)</div></div></a></div><div class="relatedPosts_item"><a href="/2021/08/18/The-Google-File-System/" title="The Google File System"><img class="relatedPosts_cover" src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/dZ4ECE.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-08-18</div><div class="relatedPosts_title">The Google File System</div></div></a></div><div class="relatedPosts_item"><a href="/2021/08/14/MapReduce-Simplified-Data-Processing-On-Large-Clusters/" title="MapReduce:Simplified Data Processing On Large Clusters"><img class="relatedPosts_cover" src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/j03zGh.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-08-14</div><div class="relatedPosts_title">MapReduce:Simplified Data Processing On Large Clusters</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 严轶轩</div><div class="framework-info"><span>驱动 </span><a target="_blank" rel="noopener" href="https://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a><span class="footer-separator">|</span><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/"><span>鄂ICP备20008765号-1</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script></body></html>