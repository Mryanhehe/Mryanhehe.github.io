<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr言的博客</title>
  
  <subtitle>记录点滴</subtitle>
  <link href="https://mryanhehe.github.io/atom.xml" rel="self"/>
  
  <link href="https://mryanhehe.github.io/"/>
  <updated>2023-05-22T08:28:46.120Z</updated>
  <id>https://mryanhehe.github.io/</id>
  
  <author>
    <name>严轶轩</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SPI机制解析</title>
    <link href="https://mryanhehe.github.io/2023/05/22/SPI%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/"/>
    <id>https://mryanhehe.github.io/2023/05/22/SPI%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/</id>
    <published>2023-05-22T07:33:44.000Z</published>
    <updated>2023-05-22T08:28:46.120Z</updated>
    
    <content type="html"><![CDATA[<p>发现hippo4j提高了不少SPI机制，也在spring的事件监听器了解到，于是想了解下SPI的实现原理</p><h3 id="什么是spi机制"><a class="markdownIt-Anchor" href="#什么是spi机制"></a> 什么是SPI机制</h3><p>SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。</p><p>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</p><p>其实我的理解就是：在不修改源码的情况下，怎么修改具体创建的对象，当然了不修改源码，肯定要修改别的东西，修改的就是配置文件了。</p><p>先给出一个例子吧</p><h4 id="自定义接口"><a class="markdownIt-Anchor" href="#自定义接口"></a> 自定义接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Developer</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体实现类"><a class="markdownIt-Anchor" href="#具体实现类"></a> 具体实现类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaDeveloper</span> <span class="keyword">implements</span> <span class="title">Developer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PythonDeveloper</span> <span class="keyword">implements</span> <span class="title">Developer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;python&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="创建配置文件"><a class="markdownIt-Anchor" href="#创建配置文件"></a> 创建配置文件</h3><p>在resource目录下创建META-INF/services/spi.Developer</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spi.JavaDeveloper</span><br><span class="line">spi.PythonDeveloper</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpiTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSayhi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ServiceLoader&lt;Developer&gt; serviceLoader = ServiceLoader.load(Developer.class);</span><br><span class="line">        serviceLoader.forEach(Developer::sayHi);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果"><a class="markdownIt-Anchor" href="#输出结果"></a> 输出结果</h4><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/3AOTMi.png" alt="3AOTMi" /></p><p>那如果想只打印java咋办呢，在spi.Developer中删除pythondeveloper就好了。</p><p>所以说Java 中的 SPI 机制就是在每次类加载的时候会先去找到 class 相对目录下的 <code>META-INF</code> 文件夹下的 services 文件夹下的文件，将这个文件夹下面的所有文件先加载到内存中，然后根据这些文件的文件名和里面的文件内容找到相应接口的具体实现类，找到实现类后就可以通过反射去生成对应的对象，保存在一个 list 列表里面，所以可以通过迭代或者遍历的方式拿到对应的实例对象，生成不同的实现。</p><p>所以会提出一些规范要求：文件名一定要是接口的全类名，然后里面的内容一定要是实现类的全类名，实现类可以有多个，直接换行就好了，多个实现类的时候，会一个一个的迭代加载。</p><p>当然这个类可以是我们自己写的类，也可以通过导入第三方库到项目中来完成加载。</p><h2 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h2><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/Qtiwh1.png" alt="Qtiwh1" /></p><p>如图，根据前缀，可以看到会从META-INF/services中查找文件</p><p>进去ServiceLoader.load</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 官网解释： 使用当前线程的上下文类加载器，为给定的服务类型创建新的服务加载器。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">        ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServiceLoader&lt;&gt;(Reflection.getCallerClass(), service, cl);</span><br><span class="line">&#125;</span><br><span class="line"># Reflection.getCallerClass():返回调用该方法的调用类</span><br><span class="line">所以，我猜测这个代码是重新返回当前类的加载器，然后在当前类(也就是SpiTest中)重新加载类</span><br></pre></td></tr></table></figure><p>进去调试</p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/NGGoZ7.png" alt="NGGoZ7" /></p><ol><li>caller: class Spitest</li><li>Sec : interface develop</li><li>Cl : AppClassloader</li></ol><p>说明猜测正确，是在当前类中，在进行一次加载</p><p>PS：<strong>我总是觉得反射和python的动态性很相关，比如这个代码用python完全可以写一个动态加载来完成，但是java因为静态语音的限制，必须要用反射才能完成，这段代码我的理解就是在运行时，根据配置文件，从指定的目录中来加载类。</strong></p><p>同时ServiceLoader实现了iterator接口，但因为拦截在，只有在serviceLoader.forEach，才会完成真正的加载，代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;S&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create lookup iterator if needed</span></span><br><span class="line">        <span class="keyword">if</span> (lookupIterator1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lookupIterator1 = newLookupIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;S&gt;() &#123;</span><br><span class="line">            <span class="comment">// record reload count</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> expectedReloadCount = ServiceLoader.<span class="keyword">this</span>.reloadCount;</span><br><span class="line">            <span class="comment">// index into the cached providers list</span></span><br><span class="line">            <span class="keyword">int</span> index;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Throws ConcurrentModificationException if the list of cached</span></span><br><span class="line"><span class="comment">             * providers has been cleared by reload.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkReloadCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (ServiceLoader.<span class="keyword">this</span>.reloadCount != expectedReloadCount)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                checkReloadCount();</span><br><span class="line">                <span class="keyword">if</span> (index &lt; instantiatedProviders.size())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> lookupIterator1.hasNext();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                checkReloadCount();</span><br><span class="line">                S next;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; instantiatedProviders.size()) &#123;</span><br><span class="line">                    next = instantiatedProviders.get(index);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    next = lookupIterator1.next().get();</span><br><span class="line">                    instantiatedProviders.add(next);</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>具体的逻辑是在next()中实现，通过</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">next = lookupIterator1.next().get();</span><br><span class="line">instantiatedProviders.add(next);</span><br></pre></td></tr></table></figure><p>来完成对javadeveloper和pythondeveloper的动态加载</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>SPI的原理其实也挺简单的，感觉如果了解python的话，就感觉其实是把python的动态加载用反射来实现了</p><p>不过也存在以下缺点</p><p>虽然采用了延迟加载，但迭代器遍历还是会加载所有的类，可能这serviceloader当时实现也没考虑这么多，其实可以添加一些约束</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;发现hippo4j提高了不少SPI机制，也在spring的事件监听器了解到，于是想了解下SPI的实现原理&lt;/p&gt;
&lt;h3 id=&quot;什么是spi机制&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是spi机制&quot;&gt;&lt;/a&gt; 什么是SPI机制&lt;/h</summary>
      
    
    
    
    <category term="java" scheme="https://mryanhehe.github.io/categories/java/"/>
    
    
    <category term="java" scheme="https://mryanhehe.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>springboot事件监听机制</title>
    <link href="https://mryanhehe.github.io/2023/05/22/springboot%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6/"/>
    <id>https://mryanhehe.github.io/2023/05/22/springboot%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6/</id>
    <published>2023-05-22T01:14:15.000Z</published>
    <updated>2023-05-22T02:43:18.635Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看hippo4j的途中看到了springboot的ApplicationEvent，于是想了解一下springboot的监听机制<br />对zookeeper有过一些了解，可能springboot的监听机制和zookeeper也不会相差太多，都是基于观察者模式<br /><a href="https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/reference/html/spring-boot-features.html#boot-features-application-events-and-listeners">官网介绍在此</a><br /><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/IH47fx.jpg" alt="IH47fx" /><br />总结了一下</p><ol><li>除了通常的Spring框架自带的事件例如：ContextRefreshedEvent，SpringApplication还会发送一些额外的事件</li><li>对于事件的监听，需要通过监听器来实现</li><li>监听器不能通过bean注册到容器中，因为监听器在applicationcontext上下文创建成功之前调用(这点很重要，在测试中因为没有启动springapplication，这时候拿到的service是null)</li></ol><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/oeIf5c.jpg" alt="oeIf5c" /><br />用一个例子来说明</p><h4 id="事件对象"><a class="markdownIt-Anchor" href="#事件对象"></a> 事件对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserEvent</span><span class="params">(Object source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserEvent</span><span class="params">(Object source,String username)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事件源"><a class="markdownIt-Anchor" href="#事件源"></a> 事件源</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">        context.register(CouponService2.class);</span><br><span class="line">        context.refresh();</span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> UserEvent(context,<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">        context.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="监听器"><a class="markdownIt-Anchor" href="#监听器"></a> 监听器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CouponService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCoupon</span><span class="params">(UserEvent event)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;给用户[&#123;&#125;]发优惠券&quot;</span>,event.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">28</span>:<span class="number">56.407</span> [main] INFO event.CouponService2 - 给用户[张三]发优惠券</span><br></pre></td></tr></table></figure><h2 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在看hippo4j的途中看到了springboot的ApplicationEvent，于是想了解一下springboot的监听机制&lt;br /&gt;
对zookeeper有过一些了解，可能springboot的监听机制和zookeeper也不会相差太多，都是基于观察者模式&lt;b</summary>
      
    
    
    
    <category term="spring" scheme="https://mryanhehe.github.io/categories/spring/"/>
    
    
    <category term="spring" scheme="https://mryanhehe.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>hippo4j源码解析(config-zookeeper部分)</title>
    <link href="https://mryanhehe.github.io/2023/05/21/config-zookeeper%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://mryanhehe.github.io/2023/05/21/config-zookeeper%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2023-05-21T09:38:40.942Z</published>
    <updated>2023-05-21T09:49:14.784Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个hippo4j初学者，我觉得想深入了解hipp4j的最好办法就是阅读源码了<br />hippo4j是一个非常好的项目，最近也成为了一个contributor。<br /><a href="https://github.com/opengoofy/hippo4j">开源地址</a><br />我比较熟悉zookeeper，因此着重看了config-zookeeper这个例子，这个例子是用zookeeper来完成线程池的状态变更，整个逻辑看起来，感觉作者的思路非常清楚，收获很多。</p><h2 id="代码结构"><a class="markdownIt-Anchor" href="#代码结构"></a> 代码结构</h2><p>首先看他的pom.xml<br /><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/UM0ZSa.png" alt="UM0ZSa" /><br />可以看到他的依赖项</p><ol><li>hippo4j-example-core</li><li>config-spring-boot-starter<br />之后会从这两个包中加载类<br /><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/HP45mt.png" alt="HP45mt" /><br /><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/Hibbaa.png" alt="Hibbaa" /><br />上面这个包类似客户端的代码，new一个动态线程池，下面的包类似服务端的代码，负责对客户端的线程池进行注册，同时监控和消息通知。</li></ol><p>下面和客户端代码和服务端的代码来解析</p><h2 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h2><p>启动类<br /><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/KoHIjz.png" alt="KoHIjz" /><br />启动类有两个注解</p><ol><li>EnableDynamicThreadPool</li><li>SpringBootApplication<br />第一个注解的源码如下<br /><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/SQ3DGE.png" alt="SQ3DGE" /><br />也就是在运行启动类的时候，需要先加载<code>BeforeCheckConfiguration</code>和<code>MarkerConfiguration</code><br />BeforeCheckConfiguration只是一些简单的检查，并不关键<br />关键的是MarkerConfiguration，源码很简单<br /><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/mLWD5j.png" alt="mLWD5j" /><br />里面没有逻辑，只有返回一个Marker类，这个类是作为一个动态线程池的标记(正如名字一样)，可以在后面看到<br /><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/hJJUHi.png" alt="hJJUHi" /><br />这个配置类需要检查是否存在marker bean，这个也就和MarkerConfiguration注解对应上了，对于配置了MarkerConfiguration的类，容器会加载Marker Bean，然后加载<code>DynamicThreadPoolAutoConfiguration</code></li></ol><p>在解析了<code>EnableDynamicThreadPool</code>注解后，spring会接着扫描<code>cn.hippo4j.example.core</code>包，可以看下包的结构<br /><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/lcVvLP.png" alt="lcVvLP" /><br />其中大部分大部分是一些测试的例子，并没有太多逻辑，整个大头还是在服务端</p><h2 id="服务端"><a class="markdownIt-Anchor" href="#服务端"></a> 服务端</h2><p>首先会加载cn.hippo4j.config.springboot.starter.config包中的配置类(只有2、3、4会作为配置类加载)<br /><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/Z2iwTg.png" alt="Z2iwTg" /><br />按序说明每个配置类的作用</p><h3 id="bootstrapconfigproperties"><a class="markdownIt-Anchor" href="#bootstrapconfigproperties"></a> BootstrapConfigProperties</h3><p>该类是第一个引入的配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = BootstrapConfigProperties.PREFIX)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootstrapConfigProperties</span> <span class="keyword">implements</span> <span class="title">BootstrapPropertiesInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">&quot;spring.dynamic.thread-pool&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Enable dynamic thread pool.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean enable = Boolean.TRUE;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Enabled banner.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Boolean banner = Boolean.TRUE;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread pool monitoring related configuration.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> MonitorProperties monitor = <span class="keyword">new</span> MonitorProperties();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Config file type.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ConfigFileTypeEnum configFileType;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Nacos config.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; nacos;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Apollo config.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; apollo;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Zookeeper config.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; zookeeper;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * etcd config</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; etcd;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * web config</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> WebExecutorProperties web;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Notify platforms.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;NotifyPlatformProperties&gt; notifyPlatforms = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Check thread pool running status interval.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer checkStateInterval;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Default dynamic thread pool configuration.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorProperties defaultExecutor;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dynamic thread pool configuration collection.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ExecutorProperties&gt; executors;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tripartite framework thread pool adaptation set.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;AdapterExecutorProperties&gt; adapterExecutors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置文件会读取zookeeper-demo.properties和application.properties，并且根据<code>prefix = BootstrapConfigProperties.PREFIX</code>来进行装配，由此我可以知道为什么config-zookeeper可以读取zookeeper的信息了，因为从application.properties只加载了zookeeper的信息，nacos和apollo等都为空<br />同时还初始化了监听类和消息通知类</p><h3 id="confighandlerconfiguration"><a class="markdownIt-Anchor" href="#confighandlerconfiguration"></a> ConfigHandlerConfiguration</h3><p><code>BootstrapConfigProperties</code>只是读取了配置文件，<code>ConfigHandlerConfiguration</code>会根据配置文件进行初始化，选择部分代码来<br />根据名字可以看到，初始化的主要是一些handler，zookeeper、nacos等</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigHandlerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NACOS_CONFIG_MANAGER_KEY = <span class="string">&quot;com.alibaba.cloud.nacos.NacosConfigManager&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NACOS_INJECTED_BEAN_NAME = <span class="string">&quot;com.alibaba.nacos.spring.beans.factory.annotation.AnnotationNacosInjectedBeanPostProcessor&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NACOS_DATA_ID_KEY = <span class="string">&quot;nacos.data-id&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String APOLLO_NAMESPACE_KEY = <span class="string">&quot;apollo.namespace&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONSUL_DATA_KEY = <span class="string">&quot;consul.data-key&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZOOKEEPER_CONNECT_STR_KEY = <span class="string">&quot;zookeeper.zk-connect-str&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ETCD = <span class="string">&quot;etcd.endpoints&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String POLARIS = <span class="string">&quot;config.serverConnector&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BootstrapConfigPropertiesBinderAdapt <span class="title">bootstrapConfigPropertiesBinderAdapt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultBootstrapConfigPropertiesBinderAdapt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Embedded Zookeeper</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(CuratorFramework.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = BootstrapConfigProperties.PREFIX, name = ZOOKEEPER_CONNECT_STR_KEY)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedZookeeper</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ZookeeperRefresherHandler <span class="title">zookeeperRefresher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ZookeeperRefresherHandler();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>ConfigHandlerConfiguration</code>完成了zookeeper的初始化，将zookeeperRefresherHandler作为Bean加载到容器中，通过名字也可以猜到，这个类是通过监听zookeerper来刷新配置类的</p><h3 id="dynamicthreadpoolautoconfiguration"><a class="markdownIt-Anchor" href="#dynamicthreadpoolautoconfiguration"></a> DynamicThreadPoolAutoConfiguration</h3><p>初始化线程池配置，这个是整个配置最关键的一步</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(MarkerConfiguration.Marker.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = BootstrapConfigProperties.PREFIX, value = &quot;enable&quot;, matchIfMissing = true, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(BootstrapConfigProperties.class)</span></span><br><span class="line"><span class="meta">@Import(ConfigHandlerConfiguration.class)</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration(&#123;WebAdapterConfiguration.class, UtilAutoConfiguration.class, MessageConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicThreadPoolAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BootstrapConfigProperties bootstrapConfigProperties;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationContextHolder <span class="title">hippo4jApplicationContextHolder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApplicationContextHolder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NotifyConfigBuilder <span class="title">notifyConfigBuilder</span><span class="params">(AlarmControlHandler alarmControlHandler, WebThreadPoolService webThreadPoolService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConfigModeNotifyConfigBuilder(alarmControlHandler, bootstrapConfigProperties, webThreadPoolService);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolCheckAlarm <span class="title">defaultThreadPoolCheckAlarmHandler</span><span class="params">(Hippo4jSendMessageService hippo4jSendMessageService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultThreadPoolCheckAlarmHandler(hippo4jSendMessageService);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultThreadPoolConfigChangeHandler <span class="title">defaultThreadPoolConfigChangeHandler</span><span class="params">(Hippo4jSendMessageService hippo4jSendMessageService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultThreadPoolConfigChangeHandler(hippo4jSendMessageService);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebThreadPoolConfigChangeHandler <span class="title">webThreadPoolConfigChangeHandler</span><span class="params">(BootstrapConfigProperties bootstrapConfigProperties,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                             WebThreadPoolService webThreadPoolService,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                             Hippo4jSendMessageService hippo4jSendMessageService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bootstrapConfigProperties.getWeb() != <span class="keyword">null</span> &amp;&amp; StringUtil.isBlank(bootstrapConfigProperties.getWeb().getThreadPoolId())) &#123;</span><br><span class="line">            bootstrapConfigProperties.getWeb().setThreadPoolId(webThreadPoolService.getWebContainerType().getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebThreadPoolConfigChangeHandler(hippo4jSendMessageService);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DynamicThreadPoolPostProcessor <span class="title">dynamicThreadPoolPostProcessor</span><span class="params">(ApplicationContextHolder hippo4jApplicationContextHolder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DynamicThreadPoolPostProcessor(bootstrapConfigProperties);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolMonitorExecutor <span class="title">hippo4jDynamicThreadPoolMonitorExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolMonitorExecutor(bootstrapConfigProperties);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DynamicThreadPoolRefreshListener <span class="title">hippo4jExecutorsListener</span><span class="params">(DefaultThreadPoolConfigChangeHandler threadPoolConfigChange,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                     ConfigModeNotifyConfigBuilder configModeNotifyConfigBuilder,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                     Hippo4jBaseSendMessageService hippoBaseSendMessageService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DynamicThreadPoolRefreshListener(threadPoolConfigChange, configModeNotifyConfigBuilder, hippoBaseSendMessageService);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AdapterExecutorsRefreshListener <span class="title">hippo4jAdapterExecutorsListener</span><span class="params">(DynamicThreadPoolAdapterRegister dynamicThreadPoolAdapterRegister)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AdapterExecutorsRefreshListener(dynamicThreadPoolAdapterRegister);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformsRefreshListener <span class="title">hippo4jPlatformsListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PlatformsRefreshListener();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebExecutorRefreshListener <span class="title">hippo4jWebExecutorListener</span><span class="params">(WebThreadPoolConfigChangeHandler threadPoolConfigChange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebExecutorRefreshListener(threadPoolConfigChange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DynamicThreadPoolAdapterRegister <span class="title">threadPoolAdapterRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DynamicThreadPoolAdapterRegister(bootstrapConfigProperties);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DynamicThreadPoolBannerHandler <span class="title">threadPoolBannerHandler</span><span class="params">(ObjectProvider&lt;BuildProperties&gt; buildProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DynamicThreadPoolBannerHandler(bootstrapConfigProperties, buildProperties.getIfAvailable());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DynamicThreadPoolConfigService <span class="title">dynamicThreadPoolConfigService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DynamicThreadPoolConfigService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从注解可以看到一个<code>@ConditionalOnBean(MarkerConfiguration.Marker.class)</code>，如同前文所讲，这个注解和<code>EnableDynamicThreadPool</code>联系上啦<br /><code>DynamicThreadPoolAutoConfiguration</code>会引入如下配置类</p><ol><li>WebAdapterConfiguration(和web通信有关)</li><li>UtilAutoConfiguration(web通信)</li><li>MessageConfiguration(消息通知，里面是关于钉钉、微信等组件的处理逻辑，现在我们先不关心这些很细致的配置，还是着眼于消息是如何产生， 如何发送)<br />在看下里面的组件，加载了如下组件</li><li>ApplicationContextHolde(环境变量)</li><li>NotifyConfigBuilder(消息发送)</li><li>ThreadPoolCheckAlarm(线程池状态检查)</li><li>DefaultThreadPoolConfigChangeHandler(状态变更)</li><li>ThreadPoolMonitorExecutor(线程池监控)</li><li>DefaultThreadPoolCheckAlarmHandler(默认线程池检查)</li><li>DynamicThreadPoolRefreshListener(线程池对zookeeper的监听)<br />暂时列举了几个关键的，可以看出这个配置类会加载关于线程池的bean，比如监听、状态变更、通知等组件，后面着重看这几个组件的逻辑</li></ol><h3 id="zookeeper注册"><a class="markdownIt-Anchor" href="#zookeeper注册"></a> zookeeper注册</h3><p>这段并没有代码，其中的原因让我想了很久才想通，所以还是在这里写一下<br />线程池是怎么注册到zookeeper中的？<br />并不是通过先生成了线程池，再把这个线程池注册到zookeeper，而是一开始就配置好线程池的配置，将配置写入zookeeper，然后springboot根据zookeeper中的配置来生成线程池，是先有的线程池配置，再有的线程池，也就是说，在线程池还没有创建的时候，线程池的配置就已经注册到了zookeeper中。<br />后续想修改线程池，直接修改zookeeper中的配置，然后服务端通过监听起得到修改的内容，再修改线程池</p><p>这样看起来很绕，不错它的好处就是<br /><strong>线程池是不知道zookeeper存在的</strong><br />思考一下生成线程池的逻辑</p><ol><li>通过zookeeper获得配置</li><li>根据配置来设置线程池</li><li>有变更，再重新设置线程池的配置<br />如果没有zookeeper，也就是没有1和3，第一步也只是拿到一个默认配置，也不影响线程池的生成，也没有后续的变更，线程池是完全不知道zookeeper的存在的。<br />这样设计，在实现线程池的时候耦合度很低，只需要设置线程池的逻辑就好了</li></ol><h3 id="状态变更"><a class="markdownIt-Anchor" href="#状态变更"></a> 状态变更</h3><p>状态的监听，肯定涉及到zookeeper的监听器模块，监听器是在什么时候设置的呢？<br />在<code>configHandlerConfiguration</code>中有一个</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ZookeeperRefresherHandler zookeeperRefresher() &#123;  </span><br><span class="line">    return new ZookeeperRefresherHandler();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ZookeeperRefresherHandler代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; zkConfigs = bootstrapConfigProperties.getZookeeper();</span><br><span class="line">        curatorFramework = CuratorFrameworkFactory.newClient(zkConfigs.get(ZK_CONNECT_STR),</span><br><span class="line">                <span class="keyword">new</span> ExponentialBackoffRetry(BASE_SLEEP_TIME_MS, MAX_RETRIES));</span><br><span class="line">        String nodePath = ZKPaths.makePath(ZKPaths.makePath(zkConfigs.get(ROOT_NODE),</span><br><span class="line">                zkConfigs.get(CONFIG_VERSION)), zkConfigs.get(NODE));</span><br><span class="line">        <span class="keyword">final</span> ConnectionStateListener connectionStateListener = (client, newState) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (newState == ConnectionState.CONNECTED) &#123;</span><br><span class="line">                loadNode(nodePath);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newState == ConnectionState.RECONNECTED) &#123;</span><br><span class="line">                loadNode(nodePath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">final</span> CuratorListener curatorListener = (client, curatorEvent) -&gt; &#123;</span><br><span class="line">            <span class="keyword">final</span> WatchedEvent watchedEvent = curatorEvent.getWatchedEvent();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != watchedEvent) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (watchedEvent.getType()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> NodeChildrenChanged:</span><br><span class="line">                    <span class="keyword">case</span> NodeDataChanged:</span><br><span class="line">                        loadNode(nodePath);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        curatorFramework.getConnectionStateListenable().addListener(connectionStateListener);</span><br><span class="line">        curatorFramework.getCuratorListenable().addListener(curatorListener);</span><br><span class="line">        curatorFramework.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>newClient负责建立和zookeeper的建立，通过建立一个监听器connectionStateListener，通过监听器触发loadNode方法</p><p>loadNode源码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadNode</span><span class="params">(String nodePath)</span> </span>&#123;</span><br><span class="line">        String content = nodePathResolver(nodePath);</span><br><span class="line">        <span class="keyword">if</span> (content != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dynamicRefresh(content);</span><br><span class="line">            registerNotifyAlarmManage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>dynamicRefresh方法通过nodePath得到变更的内容，动态刷新BootstrapConfigProperties，然后回到<strong>zookeeper注册</strong>，通过BootstrapConfigProperties重新注册线程池，完成线程池的变更<br />dynamicRefresh ---- dynamicRefresh ---- publishDynamicThreadPoolEvent<br />这一条调用链会发送一个事件，dynamicRefresh源码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dynamicRefresh</span><span class="params">(String configContent, Map&lt;String, Object&gt; newValueChangeMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Map&lt;Object, Object&gt; configInfo = ConfigParserHandler.getInstance().parseConfig(configContent, bootstrapConfigProperties.getConfigFileType());</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtil.isNotEmpty(newValueChangeMap)) &#123;</span><br><span class="line">                Optional.ofNullable(configInfo).ifPresent(each -&gt; each.putAll(newValueChangeMap));</span><br><span class="line">            &#125;</span><br><span class="line">            BootstrapConfigProperties binderCoreProperties = bootstrapConfigPropertiesBinderAdapt.bootstrapCorePropertiesBinder(configInfo, bootstrapConfigProperties);</span><br><span class="line">            publishDynamicThreadPoolEvent(binderCoreProperties);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Hippo4j config mode dynamic refresh failed.&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>publishDynamicThreadPoolEvent</code>将配置文件封装成一个事件,后面就是监听器的事情了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicThreadPoolRefreshListener</span> <span class="keyword">extends</span> <span class="title">AbstractRefreshListener</span>&lt;<span class="title">ExecutorProperties</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(Hippo4jConfigDynamicRefreshEvent event)</span> </span>&#123;</span><br><span class="line">        BootstrapConfigProperties bindableConfigProperties = event.getBootstrapConfigProperties();</span><br><span class="line">        List&lt;ExecutorProperties&gt; executors = bindableConfigProperties.getExecutors();</span><br><span class="line">        <span class="keyword">for</span> (ExecutorProperties properties : executors) &#123;</span><br><span class="line">            String threadPoolId = properties.getThreadPoolId();</span><br><span class="line">            <span class="keyword">if</span> (!match(properties)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Check whether the notification configuration is consistent, this operation will not trigger the notification.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            checkNotifyConsistencyAndReplace(properties);</span><br><span class="line">            <span class="keyword">if</span> (!checkConsistency(threadPoolId, properties)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dynamicRefreshPool(threadPoolId, properties);</span><br><span class="line">            ExecutorProperties beforeProperties = GlobalCoreThreadPoolManage.getProperties(properties.getThreadPoolId());</span><br><span class="line">            GlobalCoreThreadPoolManage.refresh(threadPoolId, failDefaultExecutorProperties(beforeProperties, properties));</span><br><span class="line">            ChangeParameterNotifyRequest changeRequest = buildChangeRequest(beforeProperties, properties);</span><br><span class="line">            log.info(CHANGE_THREAD_POOL_TEXT,</span><br><span class="line">                    threadPoolId,</span><br><span class="line">                    String.format(CHANGE_DELIMITER, beforeProperties.getCorePoolSize(), changeRequest.getNowCorePoolSize()),</span><br><span class="line">                    String.format(CHANGE_DELIMITER, beforeProperties.getMaximumPoolSize(), changeRequest.getNowMaximumPoolSize()),</span><br><span class="line">                    String.format(CHANGE_DELIMITER, beforeProperties.getQueueCapacity(), changeRequest.getNowQueueCapacity()),</span><br><span class="line">                    String.format(CHANGE_DELIMITER, beforeProperties.getKeepAliveTime(), changeRequest.getNowKeepAliveTime()),</span><br><span class="line">                    String.format(CHANGE_DELIMITER, beforeProperties.getExecuteTimeOut(), changeRequest.getNowExecuteTimeOut()),</span><br><span class="line">                    String.format(CHANGE_DELIMITER, beforeProperties.getRejectedHandler(), changeRequest.getNowRejectedName()),</span><br><span class="line">                    String.format(CHANGE_DELIMITER, beforeProperties.getAllowCoreThreadTimeOut(), changeRequest.getNowAllowsCoreThreadTimeOut()));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                threadPoolConfigChange.sendPoolConfigChange(changeRequest);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Failed to send Chang smart application listener notice. Message: &#123;&#125;&quot;</span>, ex.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我摘出关键代码，在<code>onApplicationEvent</code>方法中，通过事件拿到修改之后的配置文件，修改线程池的参数，同时<code>threadPoolConfigChange.sendPoolConfigChange(changeRequest)</code>来发送变更请求<br />registerNotifyAlarmManage源码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerNotifyAlarmManage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        bootstrapConfigProperties.getExecutors().forEach(executorProperties -&gt; &#123;</span><br><span class="line">            ThreadPoolNotifyAlarm threadPoolNotifyAlarm = <span class="keyword">new</span> ThreadPoolNotifyAlarm(</span><br><span class="line">                    executorProperties.getAlarm(),</span><br><span class="line">                    executorProperties.getCapacityAlarm(),</span><br><span class="line">                    executorProperties.getActiveAlarm());</span><br><span class="line">            threadPoolNotifyAlarm.setInterval(executorProperties.getNotify().getInterval());</span><br><span class="line">            threadPoolNotifyAlarm.setReceives(executorProperties.getNotify().getReceives());</span><br><span class="line">            GlobalNotifyAlarmManage.put(executorProperties.getThreadPoolId(), threadPoolNotifyAlarm);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再修改了BootstrapConfigProperties后，重新读取BootstrapConfigProperties，然后把这个封装成一个ThreadPoolNotifyAlarm事件，把这个放到GlobalNotifyAlarmManage中<br />OK,状态变更的逻辑就完成了</p><h3 id="消息通知"><a class="markdownIt-Anchor" href="#消息通知"></a> 消息通知</h3><p>消息通知的核心逻辑在<code>hippo4jSendMessageService</code>中，在<code>DynamicThreadAutoConfigutation</code>中完成<br />这段逻辑比较简单了，就是根据配置文件加载通知平台的配置，然后根据配置来分发信息</p><h3 id="线程池检查"><a class="markdownIt-Anchor" href="#线程池检查"></a> 线程池检查</h3><p><code>DefaultThreadPoolCheckAlarmHandler</code>会定期检查线程池状态，源码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadPoolCheckAlarmHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">ThreadPoolCheckAlarm</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        alarmNotifyExecutor.scheduleWithFixedDelay(<span class="keyword">this</span>, <span class="number">0</span>, checkStateInterval, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; listThreadPoolId = GlobalThreadPoolManage.listThreadPoolId();</span><br><span class="line">        listThreadPoolId.forEach(threadPoolId -&gt; &#123;</span><br><span class="line">            ThreadPoolNotifyAlarm threadPoolNotifyAlarm = GlobalNotifyAlarmManage.get(threadPoolId);</span><br><span class="line">            <span class="keyword">if</span> (threadPoolNotifyAlarm != <span class="keyword">null</span> &amp;&amp; threadPoolNotifyAlarm.getAlarm()) &#123;</span><br><span class="line">                DynamicThreadPoolWrapper wrapper = GlobalThreadPoolManage.getExecutorService(threadPoolId);</span><br><span class="line">                ThreadPoolExecutor executor = wrapper.getExecutor();</span><br><span class="line">                checkPoolCapacityAlarm(threadPoolId, executor);</span><br><span class="line">                checkPoolActivityAlarm(threadPoolId, executor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>DefaultThreadPoolCheckAlarmHandler</code>本质就是一个定时线程，定期来执行<code>checkPoolCapacityAlarm</code>和<code>checkPoolActivityAlarm</code>，如果不正常，则和状态变更一样，调用<code>hippo4jSendMessageService.sendAlarmMessage</code></p><h3 id="线程池注册"><a class="markdownIt-Anchor" href="#线程池注册"></a> 线程池注册</h3><p>这一步比较简单，用到了一个springboot的生命周期</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DynamicThreadPoolPostProcessor <span class="title">dynamicThreadPoolPostProcessor</span><span class="params">(ApplicationContextHolder hippo4jApplicationContextHolder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DynamicThreadPoolPostProcessor(bootstrapConfigProperties);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/WblAJA.png" alt="WblAJA" /></p><p>继承了BeanPostProcessor，确保了在线程池生成之后，将线程池注册到管理中心</p><h2 id="收获"><a class="markdownIt-Anchor" href="#收获"></a> 收获</h2><p>关于如何用zookeeper来监听配置信息，以及如何发送消息消息这一整套逻辑算是搞通了，感受就是作者搭建这个框架非常漂亮，耦合度很低，这样一个缺点就是看源码的话，并不太好弄懂，我也是不断地调试最后才搞清楚，中间还发现了一个bug，提交了pr，也是被成功merge，<a href="https://github.com/opengoofy/hippo4j/pull/1302">地址在此</a>算是一件很有成就感的事情了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作为一个hippo4j初学者，我觉得想深入了解hipp4j的最好办法就是阅读源码了&lt;br /&gt;
hippo4j是一个非常好的项目，最近也成为了一个contributor。&lt;br /&gt;
&lt;a href=&quot;https://github.com/opengoofy/hippo4j</summary>
      
    
    
    
    <category term="Java" scheme="https://mryanhehe.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://mryanhehe.github.io/tags/Java/"/>
    
    <category term="线程池" scheme="https://mryanhehe.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper-wait-free-coordination-for-Internet-scale-systems</title>
    <link href="https://mryanhehe.github.io/2021/11/02/ZooKeeper-wait-free-coordination-for-Internet-scale-systems/"/>
    <id>https://mryanhehe.github.io/2021/11/02/ZooKeeper-wait-free-coordination-for-Internet-scale-systems/</id>
    <published>2021-11-01T16:05:04.000Z</published>
    <updated>2021-11-11T10:23:14.387Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对谷歌论文：ZooKeeper: wait-free coordination for Internet-scale systems的笔记</p><p>Url:<a href="http://nil.csail.mit.edu/6.824/2020/papers/zookeeper.pdf">http://nil.csail.mit.edu/6.824/2020/papers/zookeeper.pdf</a></p><h1 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> Abstract</h1><p>ZooKeeper希望创建一个简单，高性能的内核，用于在客户端构建更复杂的协调原语。</p><p>ZooKeeper借口可以提供高性能服务实现。除了无等待之外，ZooKeeper保证每个client一个FIFO的请求队列，线性化所有改变ZooKeeper状态的请求。</p><h1 id="introduction"><a class="markdownIt-Anchor" href="#introduction"></a> Introduction</h1><p>在设计ZooKeeper的API时，我们不再使用阻塞元语，比如锁。阻塞协调服务的原语可能会导致其他问题，包括缓慢或错误的客户端对更快的客户端的性能产生负面影响。如果服务进程请求依赖其他client的响应或者失败检测，实现起来会更加麻烦。因此，在Zookeeper中， 可以操作层次化的无等待数据对象，就像文件系统一样。ZooKeeper类似其他任何一个文件系统。</p><p>尽管无锁对性能和和错误容错很关键，但是处理协作还是不够，因此我们提供了事务的顺序保证。特别是，对client所有操作的FIFO顺序化以及将写串行化可以实现我们的服务，并且实现协作元语。</p><p>ZooKeeper由多个服务器组成，用复制来实现高性能和高可用性。高性能体现在可以让由大量进程组成的应用通过使用协作内核来管理各个层级的协作。我们可以通过简单的流水线架构来实现ZooKeeper，即使有大量请求未完成，仍然保持低延时。这样的架构自然允许来自client的操作以FIFO的顺序执行。保证FIFO client顺序，允许client去异步提交操作。通过异步操作，client可以在同一时刻有多个未完成的操作。该特性很关键，因为当一个client成为leader时，他必须管理元数据并相应更新他。如果没有多个未完成操作的可能性，初始化可能是秒级而不是亚秒级。</p><p>为了保证更新操作满足串行，实现了基于leader的原子传播协议，叫做Zab。ZooKeeper应用的典型负载主要是读操作，因此渴望去扩展读吞吐量。在ZooKeeper中，服务器在本地处理读操作，并不适用Zab来排序。</p><p>在client端缓存数据也是一个提高读性能的关键技术，比如缓存leader。ZooKeeper使用监听机制，让client来缓存数据而不是直接管理client的数据。通过该机制，client可以对一个给定数据对象进行监听，当更新时，收到通知。Chubby直接管理client缓存。它阻止更新来验证缓存正在更改的数据的所有客户端的缓存。如果client其中一个运行速度慢或者出现异常，更新会慢下来。Chubby用租贷来阻止Client异常来无限阻止系统。然而租约只限制了缓慢或错误的客户端的影响，而ZooKeeper监听则完全避免了这个问题。</p><h2 id="贡献"><a class="markdownIt-Anchor" href="#贡献"></a> 贡献</h2><ol><li>协作内核：提出了一种在分布式系统中使用的具有宽松一致性保证的无等待协调服务</li><li>协作方法：如何构建更高级的协作元语</li><li>经验与协调</li></ol><h2 id="zookeeper的服务"><a class="markdownIt-Anchor" href="#zookeeper的服务"></a> ZooKeeper的服务</h2><p>client通过zookeeper库提供的API来发送请求，除了通过client api来暴露zookeeper服务接口，client库也会管理client和zookeeper server的网络连接。</p><h2 id="术语"><a class="markdownIt-Anchor" href="#术语"></a> 术语</h2><ol><li>client： ZooKeeper服务的使用者</li><li>server：提供服务的进程</li><li>znode：zookeeper数据中的内存数据节点，被组织在称为数据树的分层名称空间中。</li></ol><p>client在连接zookeeper时会创建一个session和在通过session handle发送请求</p><h2 id="服务概览"><a class="markdownIt-Anchor" href="#服务概览"></a> 服务概览</h2><p>ZooKeerper提供给client一系列抽象的数据节点（znode），通过分层命名空间来组织。分层中的znode是一个数据对象，client通过ZooKeeper API来控制。分类空间多用于文件系统，是一个组织数据对象的好方法。因为用户可以使用该抽象，可以更好的管理应用程序的元数据。对于一个znode，我们使用标准的unit 文件路径来标识</p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/5xoahH.png" alt="" /></p><p>client可以创建两种类型的znode</p><ol><li>regular：client显式创建和删除znode</li><li>ephemeral：client创建该znode，要么显式删除，要么等到session结束时系统自动删除</li></ol><p>当创建一个znode时，client可以设置一个连续的标记。使用顺序标记集创建的节点在其名称后附加一个单调递增的计数器的值。如果n是一个新的znode，p是父znode，n则永远不会小于在p节点下创建的znode的值。</p><p>ZooKeeper实现了watches，允许client及时接收更改通知，而不需要轮询。当client发出一个设置了监视标志的读操作时，除非服务器承诺在返回的信息发生更改时通知客户端，否则操作将正常完成。监听和session联系在一起的一次性触发器，一旦触发或者session结束，触发器就注销。监听只是表明改变发生，但是不会提供任何操作。比如一个client发送请求getData(&quot;/foo&quot; , true)，在“/foo“改变两次之前，client会触发watch event告诉他foo的数据已经改变。session event，比如连接丢失也会发送一个watch callback给client，以便告诉他watch event可能延迟。</p><p>**数据模型：**zookeeper的数据模型本质上是一个带有简化API的文件系统，只进行数据的读和写，或者一个带有层次空间的key的key/value表格。层次命名空间对于为不同应用程序的名称空间定位子树和设置对这些子树的访问权限非常有用。</p><p>不像文件系统的文件，znode不是用来存储通用数据的。znode映射成client应用程序的抽象，通常存储用于协调目的的元数据。比如figure1 ，应用程序1（/app1）和应用程序2（/app2）。app1的子树实现了一个简单的组成员协议:每个client进程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>在/app1下创建一个znode<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>p</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">p_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，只要进程一直运行，znode就会一直存在。</p><p>尽管znode设计出来不是为了数据存储，但zookeeper允许client去存储一些信息，比如用于分布式计算的元数据或者配置文件。比如，在基于leader的应用程序中，让server知道当前leader是谁很有用。为了实现这一功能，我们可以将当前leader写在znode中。znode还将元数据与时间戳和版本控制器相关联，从而允许client去跟踪znode的改变，根据znode的版本执行更新。</p><p>**session：**client连接zookeeper会出初始化一个session。session有一个timeout。zookeeper如果没有通过session在timeout时间段内收到任何信息，会认为client出现故障。当client显式关闭session handle或者zookeeper发现client出现故障，session会自动结束。通过session，client可以观察一系列可以反应执行操作的状态改变。session可以当client在zookeeper集群中从一个server移动到另一个server，因此实现了zookeeper server的持久化。</p><h2 id="clint-api"><a class="markdownIt-Anchor" href="#clint-api"></a> Clint api</h2><ol><li>Create(path , data , flags):在path创建一个znode，并且在znode中存储data，返回znode的名字。flags可以让client选择znode的种类----regular，ephemeral，并设置连续标志</li><li>delete(path ,version)：如果znode是期望的verson，删除path路径的znode</li><li>exists(path ,watch)：如果path的znode存在，则返回true，否则返回false。watch标识可以让client去给znode设置一个watch</li><li>getData(path , watch)：返回znode的data和元数据，比如版本信息等。watch标识和exists一样。除非znode不存在，否则zookeeper一定会给znode设置watch</li><li>setData(path , data ,version)：如果versino是znode 的版本号，则将data[]写入znode</li><li>getChildren(path , watch)：返回znode的孩子的名字</li><li>sync(path)：在操作开始时等待所有挂起的更新，以传播到客户端连接的服务器。该路径当前被忽略</li></ol><p>所有的方法都有同步和异步的版本。当执行单个zookeeper操作，并且没有并发任务去执行时，可以使用同步，他会让zookeerer调用或者阻塞。异步API可以让应用程序控制多个zookeeper操作并且同步运行。ZooKeeper客户端保证按顺序调用返回每个操作的相应回调。</p><p>zookeeper并不会使用session handle去访问znode。每个请求都会包含正在执行操作的znode的完整路径。该操作不仅仅简化了api(没有open()和close()操作)，而且不需要server去维持额外的状态。(否则可能需要维护handle的状态)</p><p>每个更新方法都带有一个版本号，这样使得条件更新成为可能。如果znode真实的版本号不符合期望的版本号，更新会失败并出现版本error。如果版本号是-1，则不会进行版本检查</p><h2 id="zookeeper的保证"><a class="markdownIt-Anchor" href="#zookeeper的保证"></a> zookeeper的保证</h2><ol><li>串行写：更新zookeeper状态的请求都会被串行化并且遵照优先权</li><li>FIFO读：client的读请求会按照请求发送的顺序执行</li></ol><p>zookeeper的串行并不是原始的串行，而是A-linearizability（异步串行）。在最初串行的定义中，一个client只能有悬挂的操作。在zookeeper中，允许多个悬挂的操作，zookeeper会按序选择来保证没有client的悬挂操作有特殊性，从而实现先进先出。</p><p>线性化对象的结果也适用于A-线性化，因为A-线性化也满足线性化。仅仅只有更新请求会被A-线性化，zookeeper在每个备份server本地处理读请求，这使得服务被加入到系统中实现现行增长。</p><p>为了理解这两个保证如何实现，想象一个场景：一个系统由一系列进程组成，选择一个进程去指挥worker进程。当一个新leader掌控系统时，他必须改变一系列配置参数，并且更新完需要通知其他的进程，我们因此提出两个需求</p><ol><li>当leader开始更新时，我们不希望其他进程使用正在更新的配置，即仍然使用过去的配置文件</li><li>如果leader在配置更新前就死亡，我们不希望其他进程去用这个没有更新完的配置文件。</li></ol><p>一般的分布式锁，比如chubby提供的，可以实现第一个需求，但是无法实现第二个需求。在zookeeper中，新leader可以委托一个path作为ready znode，其他的进程仅仅当该znode存在时，才可以使用配置文件。新leader通过删除ready znode，更改配置znode，创建ready znode来更新配置文件。所有这些更改都可以通过管道处理并异步发出，以快速更新配置状态。尽管更改操作的延迟大约是2毫秒，但如果一个新的leader必须更新5000个不同的znode，那么如果请求一个接一个地发出，则需要10秒。但是通过异步发出请求会使得延时小于1秒。由于排序的保证，如果一个进程看到了ready znode，他一定可以知道新leader完成了所有的更新操作。如果一个新leader在ready znode创建之前死了，其他的进程知道配置文件还没有更新完，于是则不会使用。</p><p><strong>上述策略还存在一个问题，如果一个进程在新leader开始更新之前看到了ready znode，并且在leader更新znode的时候读取配置文件会发生什么？</strong></p><p>这个问题可以通过通知的排序保证来解决。如果client正在监视更改，则客户端将在看到更改后系统的新状态之前看到通知事件。因此，如果读取ready znode的进程请求通知对该znode的更改，那么它将看到一个通知，在它可以读取任何新配置之前通知客户机该更改。</p><p>zookeeper保证活力和持久性</p><ol><li>只有绝大多数server可以通信的时候，服务才可用</li><li>任何一个成功的操作都会被持久化。</li></ol><h2 id="元语示例"><a class="markdownIt-Anchor" href="#元语示例"></a> 元语示例</h2><p>如何使用zookeeper的api实现更强大的元语。 ZooKeeper服务对这些更强大的原语一无所知，因为它们完全是在客户端通过ZooKeeper客户端API实现的。基本的元语比如组成员和配置管理是无等待的。其他的，比如回合，client需要等待事件。尽管zookeeper无等待，但是我们可以通过zookeeper实现有效的阻塞元语。zookeeper的顺序保证允许对系统状态进行推理，watch机制允许有效的等待。</p><h3 id="配置管理"><a class="markdownIt-Anchor" href="#配置管理"></a> 配置管理</h3><p>zookeeper可以用来在分布式应用中动态管理配置。配置以最简单的形式存储在znode中,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>C</mi></msub></mrow><annotation encoding="application/x-tex">z_C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。进程会通过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>C</mi></msub></mrow><annotation encoding="application/x-tex">z_C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的完整路径来访问。启动进场会通过设置watch标志为true来读取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>C</mi></msub></mrow><annotation encoding="application/x-tex">z_C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的配置。如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>C</mi></msub></mrow><annotation encoding="application/x-tex">z_C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的配置改变，进程会收到通知，读取新的配置，再次设置watch标志为true。</p><p>在该策略中，和其他大多数一样使用watch机制，watches用来保证进程收到最新的信息。</p><p>例如，如果一个监视<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">z_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的进程被通知<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">z_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>发生了变化，并且在它发出对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>C</mi></msub></mrow><annotation encoding="application/x-tex">z_C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的读取之前，会收到更新通知，在收到更新通知之前，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>C</mi></msub></mrow><annotation encoding="application/x-tex">z_C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>又收到了三个更新，进程不会收到三个更新通知。但是这并不影响进程的行为，因为这三个时间只是简单的通知进程他已经知道的事----<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">z_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的信息已经过期了。</p><h3 id="汇合"><a class="markdownIt-Anchor" href="#汇合"></a> 汇合</h3><p>在分布式系统中，最终的系统配置并不是很清楚。例如，client可能希望启动一个master进程和几个worker进程，但启动进程是由调度程序完成的，因此客户机无法提前知道它可以提供给工作进程以连接到主进程的地址和端口等信息。</p><p>我们可以使用汇合znode来解决，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">z_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，是一个由client创建的znode。client传递<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">z_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的完成路径作为master和worker进程的启动参数。当master进程启动时，他会将地址和端口填入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">z_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中，当worker进程启动时，会读取<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">z_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,同时设置watch为true。如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">z_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>仍然没有被填满，worker会等待直到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">z_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>更新时收到通知。如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">z_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是一个ephemeral node，master和worker进程可以鉴定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">z_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是否被删除来判断是否结束自身。</p><h3 id="组管理"><a class="markdownIt-Anchor" href="#组管理"></a> 组管理</h3><p>可以利用ephemeral node来实现组管理。具体来说，我们可以使用ehpemeral node来观察创建node的状态。</p><p>最先为讨一个znode,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">z_g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>去代表一个组。当组的一个进程启动时，会在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">z_g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>下创建一个znode。如果每个进程都有一个标识名字或者一个标识符，那个这个可以作为znode的名字，否则进程创建一个带有SEQUENTIAL 标志的znode去维护名字的分配。进程可以将子进程的信息放入子znode中，比如进程的address，port等</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">z_g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>的子znode正常创建后，不需要做什么其他的，如果进程失败或者结束，表示进程的znode会自动移除(因为进程结果，进程和znode的session会消失，系统会自动移除znode)。</p><p>进程可以通过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>z</mi><mi>g</mi></msub></mrow><annotation encoding="application/x-tex">z_g</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.04398em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>来了解组的信息。如果进程希望监视组成员关系的变化，则进程可以将监视标志设置为true，并在收到更改通知时刷新组信息(随时将监视标志设置为true)。</p><h3 id="简单锁"><a class="markdownIt-Anchor" href="#简单锁"></a> 简单锁</h3><p>尽管zookeeper没有锁服务，但是可以用来实现锁。 使用ZooKeeper的应用程序通常使用定制的同步原语。</p><p>最简单的锁实现使用“锁文件”。锁由znode表示，为了得到锁，client尝试用EPHEMERAL标志创建指定的znode。如果创建成功，client拿到锁，否则，client可以用watch标志来读取znode，如果znode死亡，会通知该client。当进程死亡或者显式删除znode，client会释放锁。其他正在等待锁的client在观察到znode被删除后，会再次尝试获取锁</p><p>虽然这个简单的锁定协议可以工作，但它确实存在一些问题。首先，它受到从众效应的影响。如果有很多客户端在等待获取锁，那么当锁被释放时，即使只有一个客户端可以获取锁，它们也会竞相获取锁。其次，它只实现排他锁。</p><h3 id="没有从众效应的简单锁"><a class="markdownIt-Anchor" href="#没有从众效应的简单锁"></a> 没有从众效应的简单锁</h3><p>定义一个锁znode l来实现</p><p>我们直观地排列所有请求锁的client，每个client按照请求到达的顺序获得锁。希望获得锁的client做如下操作</p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/vjpLvG.png" alt="" /></p><p>lock命令中，使用SEQUENTIAL表示来对请求锁的client进行排序。第3行，如果client的znode有最小的序号，client会得到锁。否则，客户端将在该客户端的znode之前等待删除具有锁或将接收锁的znode。通过监听之前的一个znode，我们可以避免从众效应，只是在一个锁释放或者锁请求丢弃时唤醒一个进程。一旦被监听的znode离开，client必须检查他现在是否占有锁（之前的锁请求可能已经被放弃，但有一个序号更低的znode仍在等待或者持有锁）。</p><p>释放锁仅仅是删除znode，因为znode设置为EPHEMERAL，崩溃的进程会自动清楚锁请求或者释放持有的锁。</p><p>总结：这种锁有如下优点</p><ol><li>znode移除仅仅会唤醒一个client，因为每个znode仅仅监听前一个client，不必担心从众效应</li><li>没有轮训或者超时</li><li>通过该方式，我们可以查看zookeeper的数据来锁的数量，断锁和调试锁的问题</li></ol><h3 id="读写锁"><a class="markdownIt-Anchor" href="#读写锁"></a> 读写锁</h3><p>为了实现读/写锁，我们稍微改变锁过程，让读锁和写锁过程分开。解锁过程如上</p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/F56JgK.png" alt="" /></p><p>可能出现从众效应，如果多个读锁之前的写锁释放，多个读锁会同时请求获取锁。</p><h3 id="双重屏障"><a class="markdownIt-Anchor" href="#双重屏障"></a> 双重屏障</h3><p>双重屏障可以让client去同步计算的开始和结束。</p><p>当足够多的进程(由屏障阈值定义)加入到屏障中，进程开始计算，一旦结束就离开屏障。我们用znode来表示屏障，叫做b，每个进程p都会在b下注册，创建一个b的子znode。</p><p>当b的子znode数目超过barrier阈值时，进程可以进入barrier。当所有进程都删除了他们的子进程，进程可以离开屏障。</p><h1 id="zookeeper应用"><a class="markdownIt-Anchor" href="#zookeeper应用"></a> zookeeper应用</h1><h2 id="fetching-service"><a class="markdownIt-Anchor" href="#fetching-service"></a> Fetching service</h2><p>爬虫是搜索引擎的重要部分，雅虎会爬取上亿页面。为了效率，会有一个master进程来命令爬取页面的进程。</p><p>master进程提供爬取的配置文件，fetcher进程写状态和健康信息。</p><p>使用zookeeper作为FS的最大优点是保证master从失败中恢复，就算失败，也保证其可用性，将client和server解偶，根据读取zookeeper的状态信息来将请求重定向健康的server中</p><h2 id="katta"><a class="markdownIt-Anchor" href="#katta"></a> katta</h2><p>katta是使用zookeeper的一个分布式索引器。katta使用切片划分索引工作。</p><p>master server将切片分给slave和track进程。slave可能失败，所以当slave失败时，master必须重新分配负载。master也可能失败，所以server必须做好接管的准备。katta使用zookeeper去跟踪slave server和master的状态(使用group membership)，使用zookeeper去处理master失败(leader election)。Katta还使用ZooKeeper来跟踪和传播分片分配给slave(configuration management)。</p><h2 id="yahoo-massage-broker"><a class="markdownIt-Anchor" href="#yahoo-massage-broker"></a> Yahoo! Massage Broker</h2><p>YMB是一个分布式订阅发布系统。该系统管理着数千个主题，客户可以向这些主题发送消息，也可以从这些主题接收消息，这些主题分布在一系列服务器上，每个主题都使用主备份方案进行复制，该方案确保将消息复制到两台机器，以确保可靠的消息传递。组成YMB的服务器使用无共享的分布式架构，这使得协调对于正确的操作至关重要/。</p><p>YMB使用zookeeper来管理分布式主题(配置文件元数据)，处理系统机器的失败(failure detection and group membership)，控制系统操作。</p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/dzWOFv.png" alt="" /></p><p>每个broker domain都有一个znode，该znode对于组成YMB服务的每个活动服务器都有一个临时znode。每个YMB server都会创建一个带有负载和状态信息的ephemeral znode在nodes下面，并通过zookeeper提供group membership 和 状态信息。shutdown和migration_prohibited被所有server监听，允许YMB的集中管理。topics目录是由YMB管理的znode，里面是每个主题。这些主题znode也有子znode。表示主题的首要服务器和备份服务器以及该主题的订阅者。primate和backup server znode不仅允许server去发现管理该主题的server，并且还管理leader election和server crashes</p><h1 id="zookeeper实现"><a class="markdownIt-Anchor" href="#zookeeper实现"></a> ZooKeeper实现</h1><p>zookeeper通过在每个server备份zookeeper数据来实现高可用性。</p><p>假设server崩溃，并且会在之后恢复。</p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/taB8Px.png" alt="" /></p><p>如图，在收到一个请求后，server为执行做好准备（request processor）。如果请求需要多个server的协同（write request），需要用到一个同意协议（原子传播的一种实现），最终server提交修改到 zookeeper完全备份了所有server的数据库中。在read request情况下，server仅仅读取本地数据库的状态，并且生成一个response。</p><p>备份数据库是包含整个数据树的内存数据库，每个znode默认最大存储1MB的数据，但是这个最大值可以在特定情况下根据配置参数来修改。</p><p>为了可恢复行，zookeeper会尽快将更新记录到磁盘中，并且在数据写入内存之前，强制先将数据写入磁盘。实际上，zookeeper实现了提交操作的重放日志(预写日志)，并且定期生成内存数据库的快照。</p><p>每个zookeeper server服务client。client连接一个server来提交request。对于read request被每个server的数据库的本地副本服务，对于会改变服务状态的request，比如write request，会通过aggrement protocol来完成。</p><p>在agreement protocol中，write request会首先提交到leader，剩下的zookeeper server成为follower，接受来自leader的消息更新提案，并统一状态改变，</p><h2 id="request-processor"><a class="markdownIt-Anchor" href="#request-processor"></a> request processor</h2><p>由于消息传递层是原子的，所以我们保证本地副本永远不会分离，尽管在任何时间点，一些服务器可能比其他服务器接受更多的事务。不像client发送的request，事务是等幂的。当leader接受了一个write request，会计算如果执行该操作后系统的状态，并且将事务转换成一个得到了新状态的新事务。因为可能存在尚未应用到数据库的未执行事务，因此必须计算未来的状态。</p><p>比如，当一个client执行setData()，request的版本号满足正在更新的znode的未来版本号，服务会产生一个包含了新数据，新版本号和更新时间戳的setDataTXN。如果出现error，比如版本号不匹配或者将要更新的znode不存在，errorTXN则会产生。</p><h2 id="atomic-broadcast"><a class="markdownIt-Anchor" href="#atomic-broadcast"></a> Atomic Broadcast</h2><p>所有更新zookeeper状态的请求都会提交到leader。leader执行request，并且将变更通过Zab广播给zookeeper状态。当接受了request请求的server交付了状态变更后，会给client响应。Zab默认会使用简单多数判定来决定提案，所以Zab和zookeeper只有在大多数server都运行正常的时候工作（因此2f+1个server能容忍f个异常）。</p><p>为了实现高吞吐量，zookeeper尝试让request进程通道保持满的状态。可能在处理管道的不同部分有上千个request。因为状态变更依赖于先前状态，Zab提供了比平常的原子广播更健壮的顺序保证。更具体地说，Zab保证一个leader广播的状态变更按照它们发出的顺序传送，并且在它广播自己的状态变更之前，前leader的所有状态变更都要传送给一个已建立的ledaer。</p><p>有一些细节可以简化我们的视线，并且提高效率。使用TCP作为传输，因此消息顺序由网络来维护，这样让我们简化我们的实现。</p><p>使用Zab选择的leader作为zookeeper的leader，因此创建事务的进程也会发布事务。使用日志去跟踪提案，作为内存数据库的预写日志，这样不用将操作写入磁盘两次。</p><p>在正常的操作期间，Zab会按序一次性提交所有的操作，但是Zab不会记录每次提交记录的id，所以Zab可能在恢复期间传递操作。因为我们使用的是幂等事务，多次提交是可以接受的，只要他们按序提交。事实上，ZooKeeper要求Zab至少重新交付上次快照开始之后交付的所有消息。</p><h2 id="replicated-database"><a class="markdownIt-Anchor" href="#replicated-database"></a> Replicated Database</h2><p>每个副本在内存中都有zookeeper状态的副本。当zookeeper server从崩溃中恢复，它需要恢复到这个内部状态。 在运行服务器一段时间后，重播所有传递的消息以恢复状态将花费令人望而退却的时间，所以ZooKeeper使用定期快照，并且仅仅要求上一个快照之后的重播。</p><p>zookeeper的快照称为<strong>fuzzy snapshot</strong>，因为在快照期间不会锁定zookeeper的状态，因此，我们首先定期对树进行深度扫描，以原子方式读取每个znode的数据和元数据，并将它们写入磁盘。由于产生的fuzzy snapshot可能应用了快照生成期间交付的状态更改的某个子集，因此结果可能不对应于ZooKeeper在任何时间点的状态。然而，zookeeper的状态变更是幂等的，只要保证状态变更按序即可。</p><h2 id="client-server-interaction"><a class="markdownIt-Anchor" href="#client-server-interaction"></a> client-server interaction</h2><p>当server处理一个write request时，它还发送和清除与该更新对应的任何watch相关的通知。server按序处理write request，但是不会并发处理write和read request。这保证了通知的严格连续性。server在本地处理通知，只有和client连接的server会跟踪和触发client的通知。</p><p>read request在每个server本地处理。每个read request被处理后被标记为zxid，zxid对应server响应的最后一个事务。zxid定义了read request相对于write request的偏序。通过在本地处理read request，可以得到性能上的提升（因为没有磁盘IO）。</p><p>使用快速读取的一个缺点是不能保证读取操作的优先顺序。即，一个read操作可能返回一个过期的数据，尽管该znode的更新请求提交完成。</p><p>并不是所有的应用都需要优先顺序，但对于一些需要优先数据的应用，我们提供了sync。这个原语是异步执行的，在对它的本地副本进行所有未决的写操作之后，由leader命令执行。为了保证给定的read操作返回最新更新的值，client调用sync再读取数据。</p><p>客户端操作的FIFO顺序保证以及同步的全局保证使读操作的结果能够反映sync发出之前发生的任何更改。</p><p>zookeeper server按照FIFO顺序处理request。response包括zxid。 即使在没有活动的间隔期间，心跳消息也包括client连接到的server看到的最后一个zxid。如果client连接到一个新的server，新的server通过比较zxid来保证他的zookeeper数据试图和client的视图一样近。</p><p>如果client有一个比serve更新的视图，server不会重新建立session，直到视图一致。client保证能够找到另一个server，该server有系统的最近视图，因为client只看到已备份到大多数ZooKeeper server的更改。这种行为对于保证耐久性非常重要</p><p>为了检查client session的失败，zookeeper使用timeout。如果server在timeout内没有收到任何来自client session的消息，则判断sesion出错。如果client发送请求足够频繁，则不需要发送其他消息。否则，client需要在低活动期间发送心跳检测。如果client不能和server联系来发送request或者心跳检测，他会连接到另一台server去重新建立连接。为了防止session超时，zookeeper client库在会话空闲s/ 3ms后发送一个心跳，如果会话在2s/ 3ms内没有收到server的消息，则切换到新的server，其中s是会话超时时间，单位为毫秒。</p><h1 id="evaluation"><a class="markdownIt-Anchor" href="#evaluation"></a> Evaluation</h1><p>在50台服务器的集群上测试。每台server配备1个Xeon双核2.1GHz处理器、4GB内存、千兆以太网和2个SATA硬盘。我们将下面的讨论分为两部分:请求的吞吐量和延迟</p><h2 id="吞吐量"><a class="markdownIt-Anchor" href="#吞吐量"></a> 吞吐量</h2><p>为了评估我们的系统，我们在系统饱和时测试吞吐量，以及不同注入失败时吞吐量的变化。我们改变组成zookeeper server的数目，但是使得client的数目一致。为了模拟大型client，使用35个机器来模拟250个client。</p><p>用java实现zookeeper server，用java和c实现zookeeper client。对于这些实验，我们使用Java服务器配置到一个专用磁盘并在另一个磁盘上拍摄快照</p><p>测试client使用java的异步api，每个client都有至少100个悬挂request。每个请求都包括读操作或者1K数据的写操作。我们不展示其他操作的基准测试，因为所有修改状态的操作的性能大致相同，而非状态修改操作(不包括同步)的性能大致相同。 client每300ms发送完成操作的数量计数，我们每6s采样一次。为了防止内存溢出，server限制系统中并发请求的数量。ZooKeeper使用请求节流来防止server过载。在这些实验中，我们配置了ZooKeeper server，使其最大处理总数为2000个请求</p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/c2FLW3.png" alt="" /></p><p>在图5中，当我们改变读请求和写请求的比率时，我们显示了吞吐量，每条曲线对应于提供ZooKeeper服务的不同数量的服务器。表1显示了读取负载的极端值。读吞吐量比写吞吐量高，因为读不使用原子广播。从图中还可以看出，服务器的数量也会对广播协议的性能产生负面影响。从这些图中，我们可以观察到系统中服务器的数量不仅会影响服务可以处理的故障数量，而且还会影响系统中服务器的数量。</p><p>有两个原因导致write request耗时比read request更久。</p><ol><li>write request必须经过原子广播，需要额外的处理，增加了请求延时</li><li>Server必须确保在向leader发送确认之前，事务被记录到非易失性存储中。原则上这个要求很苛刻，但对于我们的生产系统，我们用性能换取可靠性，因为ZooKeeper构成了应用的基本事实。</li></ol><p>使用更多的server，就必须可以容错。我们通过将ZooKeeper数据划分到多个ZooKeeper集成中来提高写吞吐量</p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/PyFCXN.png" alt="" /></p><p>ZooKeeper能够通过在组成服务端的服务器上分配负载来实现如此高的吞吐量。因为宽一致性保证，因此可以均衡负载。图6显示了如果我们不做均衡负载，将所有的client都连接给leader会出什么什么情况。正如预期的那样，对于以读为主的工作负载，吞吐量要低得多，但即使对于以写为主的工作负载，吞吐量也要低得多。由服务客户端造成的额外CPU和网络负载影响了领导协调建议广播的能力，这反过来又反过来影响了整体的写性能。</p><p>原子广播协议完成了系统的大部分工作，因此比其他组件更限制了Zoo- Keeper的性能。</p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/qnMihF.png" alt="" /></p><p>图7显示了原子广播的吞吐量。为了对其性能进行基准测试，我们通过直接在leader上生成事务来模拟客户端，因此没有客户端连接或客户端请求和应答，在最大吞吐量时，原子广播称为cpu的阻碍。理论上图7应该对应zookeeper 100%的写的性能，然而zookeeper client沟通，ACL检查，请求事务版本都需要CPU。CPU的争用使得ZooKeeper的吞吐量大大低于原子广播组件。因为Zoo- Keeper是一个关键的产品组件，到目前为止，我们对ZooKeeper的开发重点一直是正确性和健壮性。通过消除额外的副本、相同对象的多重序列化、更有效的内部数据结构等，有很多机会可以显著提高性能。</p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/np5APp.png" alt="" /></p><p>为了现实系统多次出现故障，我们运行了一个由五台server组成的zookeeper。我们运行了与之前相同的饱和基准测试，但这次我们将写入百分比保持在30%，这是我们预期工作负载的保守比率。我们定期终止一些服务器进程。图8显示了随时间变化的系统吞吐量。图中标注的事件如下:</p><ol><li>follower的失败和恢复</li><li>不同的follower的失败和恢复</li><li>leader的失败</li><li>两个follower失败，然后第三个恢复</li><li>leader失败</li><li>leader恢复</li></ol><p>从这个图表中有一些重要的观察结果。首先，如果追随者失败并快速恢复，那么ZooKeeper能够维持高吞吐量，尽管失败。单个follower的故障并不会阻止服务器形成仲裁，只会减少服务器在故障前处理的读请求份额的吞吐量。 其次，我们的领袖选举算法能够快速恢复，以防止吞吐量大幅下降。</p><p>在我们的观察中，zookeeper不到200ms就可以选举一个新的leader。因此，尽管server停止服务请求的时间只有几分之一秒，但由于我们的采样周期(以秒为数量级)，我们不会观察到吞吐量为零。其次，即使follower花很长时间去恢复，zookeeper一旦再次处理request， 仍然可以提高吞吐量。在事件1、2和4之后我们没有恢复到全部吞吐量级别的一个原因是，client只有在与follower的连接中断时才切换follower。因此，在事件4之后，client不会重新分配自己，直到leader在事件3和事件5失败。在实践中，随着client的来来去去，这种不平衡会随着时间的推移而自行消除。</p><h1 id="related-work"><a class="markdownIt-Anchor" href="#related-work"></a> related work</h1><p>ZooKeeper的目标是提供一种解决分布式应用中协调进程问题的服务。为了实现这个目标，它的设计使用了以前的协调服务、容错系统、分布式算法和文件系统的思想。</p><p>我们并不是第一个提出一个用于协调分布式应用的系统的人。一些早期的系统提出了一种分布式锁服务，用于事务性应用程序，以及用于在计算机集群[19]中共享信息。最近，Chubby提出了一个系统来管理分布式应用程序的咨询。chubby和zookeeper有几个共同的目标。它还具有一个类似文件系统的接口，并使用协议协议来保证副本的一致性。但是，ZooKeeper不是锁服务。客户端可以使用它来实现。不同意chubby，zookeeper允许client去连接所有的zookeeper server，不仅仅是leaer。zookeeper client可以使用本地备份来存储数据和管理watch，因为一致性模型比chubby更宽松。这可以让zookeeper提供更高的性能，允许备份使得zookeeper有更广泛的使用。</p><p>文献中已经提出了容错系统，其目标是缓解构建容错分布式应用程序的问题。 ISIS系统将抽象的类型规范转换为容错的分布式对象，从而使容错机制对用户透明。Horus和Ensemble是由ISIS演化而来的系统。ZooKeeper支持ISIS虚拟同步的概念。最后，Totem在一个利用局域网络的硬件广播的体系结构中保证了消息传递的总顺序。Zoo- Keeper与各种各样的网络拓扑结构一起工作，这促使我们在服务器进程之间依赖TCP连接，而不是假设任何特殊的拓扑结构或硬件特性。我们也不公开任何在ZooKeeper内部使用的集成通信。</p><p>构建容错服务的一项重要技术是状态机复制，而Paxos是一种算法，能够有效地实现异步系统的复制状态机。我们使用算法来分享paxos的一些特征，但这将达成共识所需的事务日志和数据树恢复所需的预写日志结合在一起，从而实现高效的实现。</p><p>ZooKeeper类似于一个小文件系统，但它只提供了文件系统操作的一小部分，并添加了大多数文件系统中不存在的功能，如排序保证和条件写。然而，ZooKeeper watch在本质上与AFS的缓存回调相似</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是对谷歌论文：ZooKeeper: wait-free coordination for Internet-scale systems的笔记&lt;/p&gt;
&lt;p&gt;Url:&lt;a href=&quot;http://nil.csail.mit.edu/6.824/2020/papers/z</summary>
      
    
    
    
    <category term="分布式系统" scheme="https://mryanhehe.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="分布式系统" scheme="https://mryanhehe.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="文件系统" scheme="https://mryanhehe.github.io/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>python依赖树--pipdeptree</title>
    <link href="https://mryanhehe.github.io/2021/10/14/python%E4%BE%9D%E8%B5%96%E6%A0%91-pipdeptree/"/>
    <id>https://mryanhehe.github.io/2021/10/14/python%E4%BE%9D%E8%B5%96%E6%A0%91-pipdeptree/</id>
    <published>2021-10-14T08:55:10.000Z</published>
    <updated>2021-10-14T17:01:56.082Z</updated>
    
    <content type="html"><![CDATA[<p><strong>pipdeptree</strong>是一个命令行工具，用于以依赖树的形式显示已安装的python包。可以用来检测全局的库包或者虚拟环境的库包。</p><p><code>pip freeze</code>只能显示一个扁平的列表，只能显示直接依赖，而无法显示间接依赖，并且觉察三方库冲突的问题。</p><p><strong>pipdeptree</strong>可以显示间接依赖，同时发现其冲突</p><h1 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pipdeptree</span><br></pre></td></tr></table></figure><h1 id="在虚拟环境中运行"><a class="markdownIt-Anchor" href="#在虚拟环境中运行"></a> 在虚拟环境中运行</h1><p>可以直接在虚拟环境中运行pipdeptree</p><p>也可以用–python选项来指定虚拟环境</p><h1 id="用法"><a class="markdownIt-Anchor" href="#用法"></a> 用法</h1><h2 id="显示包"><a class="markdownIt-Anchor" href="#显示包"></a> 显示包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipdeptree</span><br></pre></td></tr></table></figure><h2 id="显示特定的包"><a class="markdownIt-Anchor" href="#显示特定的包"></a> 显示特定的包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipdeptree --packages xxx</span><br></pre></td></tr></table></figure><h2 id="排除特定的包"><a class="markdownIt-Anchor" href="#排除特定的包"></a> 排除特定的包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipdeptree --exclude xxx</span><br></pre></td></tr></table></figure><h2 id="生成requirementtxt"><a class="markdownIt-Anchor" href="#生成requirementtxt"></a> 生成requirement.txt</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipdeptree --warn silence | grep -E &#39;^\w+&#39;</span><br></pre></td></tr></table></figure><h2 id="生成json输出"><a class="markdownIt-Anchor" href="#生成json输出"></a> 生成json输出</h2><p>输出直接依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipdeptree --json</span><br></pre></td></tr></table></figure><p>输出间接依赖</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipdeptree --json-tree</span><br></pre></td></tr></table></figure><h2 id="可视化调用图"><a class="markdownIt-Anchor" href="#可视化调用图"></a> 可视化调用图</h2><p>首先需要安装<a href="http://www.graphviz.org">GraphViz</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pipdeptree --graph-output xxx &gt; dependencies.dot</span><br></pre></td></tr></table></figure><h2 id="usage"><a class="markdownIt-Anchor" href="#usage"></a> Usage</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usage: pipdeptree.py [-h] [-v] [-f] [--python PYTHON] [-a] [-l] [-u]</span><br><span class="line">                     [-w [&#123;silence,suppress,fail&#125;]] [-r] [-p PACKAGES]</span><br><span class="line">                     [-e PACKAGES] [-j] [--json-tree]</span><br><span class="line">                     [--graph-output OUTPUT_FORMAT]</span><br><span class="line"></span><br><span class="line">Dependency tree of the installed python packages</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -v, --version         show program&#39;s version number and exit</span><br><span class="line">  -f, --freeze          Print names so as to write freeze files</span><br><span class="line">  --python PYTHON       Python to use to look for packages in it (default:</span><br><span class="line">                        where installed)</span><br><span class="line">  -a, --all             list all deps at top level</span><br><span class="line">  -l, --local-only      If in a virtualenv that has global access do not show</span><br><span class="line">                        globally installed packages</span><br><span class="line">  -u, --user-only       Only show installations in the user site dir</span><br><span class="line">  -w [&#123;silence,suppress,fail&#125;], --warn [&#123;silence,suppress,fail&#125;]</span><br><span class="line">                        Warning control. &quot;suppress&quot; will show warnings but</span><br><span class="line">                        return 0 whether or not they are present. &quot;silence&quot;</span><br><span class="line">                        will not show warnings at all and always return 0.</span><br><span class="line">                        &quot;fail&quot; will show warnings and return 1 if any are</span><br><span class="line">                        present. The default is &quot;suppress&quot;.</span><br><span class="line">  -r, --reverse         Shows the dependency tree in the reverse fashion ie.</span><br><span class="line">                        the sub-dependencies are listed with the list of</span><br><span class="line">                        packages that need them under them.</span><br><span class="line">  -p PACKAGES, --packages PACKAGES</span><br><span class="line">                        Comma separated list of select packages to show in the</span><br><span class="line">                        output. If set, --all will be ignored.</span><br><span class="line">  -e PACKAGES, --exclude PACKAGES</span><br><span class="line">                        Comma separated list of select packages to exclude</span><br><span class="line">                        from the output. If set, --all will be ignored.</span><br><span class="line">  -j, --json            Display dependency tree as json. This will yield &quot;raw&quot;</span><br><span class="line">                        output that may be used by external tools. This option</span><br><span class="line">                        overrides all other options.</span><br><span class="line">  --json-tree           Display dependency tree as json which is nested the</span><br><span class="line">                        same way as the plain text output printed by default.</span><br><span class="line">                        This option overrides all other options (except</span><br><span class="line">                        --json).</span><br><span class="line">  --graph-output OUTPUT_FORMAT</span><br><span class="line">                        Print a dependency graph in the specified output</span><br><span class="line">                        format. Available are all formats supported by</span><br><span class="line">                        GraphViz, e.g.: dot, jpeg, pdf, png, svg</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;pipdeptree&lt;/strong&gt;是一个命令行工具，用于以依赖树的形式显示已安装的python包。可以用来检测全局的库包或者虚拟环境的库包。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip freeze&lt;/code&gt;只能显示一个扁平的列表，只能显示直接依赖，而无法显示</summary>
      
    
    
    
    <category term="第三方库" scheme="https://mryanhehe.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
    
    
    <category term="python" scheme="https://mryanhehe.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>The Google File System</title>
    <link href="https://mryanhehe.github.io/2021/08/18/The-Google-File-System/"/>
    <id>https://mryanhehe.github.io/2021/08/18/The-Google-File-System/</id>
    <published>2021-08-18T00:26:11.000Z</published>
    <updated>2021-08-24T10:15:15.045Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文是对谷歌论文：The Google File System的笔记</strong></p><p><strong>作者：Sanjay Ghemawat, Howard Gobioff, and Shun-Tak Leung Google∗</strong></p><p><strong>URL：<a href="http://nil.csail.mit.edu/6.824/2020/papers/gfs.pdf">http://nil.csail.mit.edu/6.824/2020/papers/gfs.pdf</a></strong></p><h1 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h1><p>谷歌文件系统是一个可扩展的分布式文件系统，用于大型分布式数据密集型系统。在商业硬件的基础上，提供了容错机制，并且对大量客户端提供了较高的综合性能</p><h1 id="关键词"><a class="markdownIt-Anchor" href="#关键词"></a> 关键词</h1><p>容错机制，可扩展，数据存储，集群存储</p><h1 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h1><ol><li>部件失效是正常而不是异常。文件系统由成千上百商业机器组成，被大量客户访问。这些部件的数量和质量几乎保证了某些部件在任何给定时间都不能正常工作，而某些部件则无法从当前的故障中恢复过来。</li><li>按照标准，文件是巨大的。GB文件是常见的。每个文件包含了许多应用对象，比如web文件。当定期处理快速增长，并且包含许多对象的TB文件时，按照处理KB文件的方式处理它们很不明智，尽管文件系统可以这么做。因此，设计思想和参数设置比如I/O操作和块大小必须重新考虑</li><li>大多数文件是以追加的形式改变，而不是直接重写。在文件的随机写操作实际上是不存在的。一旦写入，文件只能读取，并且只能按顺序。按照这种特性，追加成为性能优化和原子性保证的重点，在客户中缓存失去了吸引力</li><li>共同设计应用程序和文件系统API可以提高我们的灵活性，从而使整个系统受益。比如放宽了GFS的一致性模型，可以简化我们的设计，但是不会对应用造成困难。</li></ol><h1 id="设计梗概"><a class="markdownIt-Anchor" href="#设计梗概"></a> 设计梗概</h1><h2 id="假设"><a class="markdownIt-Anchor" href="#假设"></a> 假设</h2><ol><li>系统运行在许多商业部件上，这些部件容易异常。系统必须持续监控自己，在日常工作失败时，快速发现，容忍，恢复部件</li><li>系统存储许多大文件。假设有几百万个文件，通常在100MB甚至更大。GB级别的文件是很常见的，并且需要有效管理。小文件也需要支持，但我们不用特殊优化他们</li><li>工作量主要有两种读构成。大的流读和小的随机读。在大的流读中，单个操作通常读数百KB，甚至超过1MB。来自同一客户端的操作通常读一个文件的连续部分。小的随机读通常在任意文件处读几KB。性能敏感的应用程序经常对小的读取进行批处理和排序，以便在文件中稳步推进，而不是来回切换。</li><li>工作量还有大量的连续写，在文件中追加数据。一般操作大小和读差不多。一旦写入，文件便无法修改。在任意处的小规模的写也支持，但不用特殊优化</li><li>系统必须有效地为并发地追加到同一个文件的多个客户端实现定义良好的语义。我们的文件经常被用作生产者-消费者队列或多路合并。大量生产者运行在同一台机器，并发追加到文件。具有最小同步开销的原子性是必不可少的。文件可能稍后被读取，或者使用者可能同时读取文件。</li><li>高持续宽带比低延迟更重要。我们的大多数目标应用程序都注重以高速率批量处理数据，而很少有应用程序对单独的读或写有严格的响应时间要求</li></ol><h2 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h2><p>GFS提供基本操作，create , delete , open ,close ,read , write</p><p>也提供快照和追加记录。快照用较低的成本创建一个文件或目录树的副本。追加记录允许多个客户并发向同一个文件追加数据，同时保证每个用户追加操作的原子性。系统适用于实现多路合并结果和生产者-消费者队列，许多客户端可以在没有附加锁的情况下同时追加数据。</p><h2 id="架构"><a class="markdownIt-Anchor" href="#架构"></a> 架构</h2><p>GFS集群由一个master和多个chunkserver构成，并且被多个client访问。</p><p>![](/Users/yixuanyan/Library/Application Support/typora-user-images/image-20210818113543838.png)</p><p>文件被分成固定的chunk。每个chunk在被创建时被一个全局独有并且不可变的64比特chunk handle所标记。chunkserver在本地磁盘存储chunk，就像Linux 文件，根据chunk handle和比特范围来读或者写。为了稳可靠性，每个chunk在多个chunserver复制，默认是三份，尽管用户可以为了文件命名空间的不同区域指定不同的复制层次。</p><p>master维护所有文件系统元数据，包括命名空间，访问信息，文件到chunk的映射，chunk的当前位置。同时还控制系统范围的活动，比如chunk租贷管理，孤儿chunk的垃圾回收，chunkserver的chunk迁移。master定期通过心跳信息和每个chunkserver沟通，并且给予指令和收集其状态。</p><p>连接到每个应用的GFS client代码都实现了文件系统的API，并且可以和master和chunkserver沟通来代表应用进行读，写数据。client和master交互，进行元数据的操作，但是所有和传输数据相关的操作直接于chunkserver进行。</p><p>client和chunkserver都不需要缓存文件数据。客户机缓存几乎没有什么好处，因为大多数应用程序都要处理巨大的文件，或者工作集太大而无法缓存。没有缓存一致性问题，简化了客户端和整个系统。chunkserver也不需要，因为chunk存储在本地文件，所以Linux的缓冲区缓存已经将频繁访问的数据保存在内存中了。</p><h2 id="单一master"><a class="markdownIt-Anchor" href="#单一master"></a> 单一master</h2><p>单一master可以通过全局变量来chunk的转移和复制决策。但是必须减少他对读写的影响，否则可能造成读写的瓶颈（因为master只有一个）。client不与master进行读写操作，相反，client向master询问需要与哪个chunserver交互。缓存这些信息，然后在接下来的操作中直接和chunkserver交互。（<strong>有没有一点像DMA？</strong>）</p><p><strong>读操作：</strong></p><ol><li>client将应用需要的文件名和偏移量转换成文件的chunk索引</li><li>client给master发送请求，请求包含文件名字和chunk索引</li><li>master返回对应的chunk handle和副本所在的位置</li><li>client缓存该信息，以文件名和chunk索引作为key</li><li>client发送请求到副本中的一个（大多数是最近的一个）。该请求表示了chunk handle和chunk的一个比特范围。随后的信息，不需要client和master交互，除非缓存信息过期或者文件重新打开。</li><li>PS：client也可以在向master的请求中访问几个chunk，这样master可以提供多个chunk的信息，这样在之后几个chunk的访问中，client不需要请求master</li></ol><h2 id="chunk大小"><a class="markdownIt-Anchor" href="#chunk大小"></a> chunk大小</h2><p>一般选择64MB，比传统的文件系统的block尺寸更大。每个chunk副本被存储为chunk server上的一个普通Linux文件，并且只在需要时进行扩展。 惰性空间分配避免了由于内部碎片而浪费空间，这可能是针对如此大的块大小的最大反对意见。</p><p><strong>大chunk的优点：</strong></p><ol><li>减少了client和master交互的次数。因为在同一个chunk的读写只需要一次请求。因为应用通常是在大文件的顺序读或写，因此这种减少极其重要。即使是小的随机读，client也可以轻松缓存所有的chunk位置信息</li><li>对于一个chunk，client可以做的操作更多，可以通过保持一个和chunkserver的TCP唱连接来减少网络负载。</li><li>减少了存储在master的元数据大小，这样可以使我们把元数据保存在内存中。（<strong>chunk越大，chunk数量越少，元数据个数越少</strong>）</li></ol><p><strong>大chunk的缺点：</strong></p><ol><li>一个小文件可能由很少的chunk构成，可能只有一个。chunkserver存储这些chunk，可能成为多个client访问的热点。在实践中，热点并不是主要问题，因为我们的应用程序大多是顺序读取大的多块文件。  <strong>（chunk越大，一个文件所需要的chunk数量越少，更容易成为热点）（其实我感觉就算是热点，也可以通过访问其副本的方式解决吧）</strong></li><li>谷歌将GFS用在批队列系统时，出现了热点问题，解决方式是加大热点的复制因子，增加其副本，错开client的访问时间。一个潜在的解决方案是，可以让client去访问别的client的chunk</li></ol><h2 id="元数据"><a class="markdownIt-Anchor" href="#元数据"></a> 元数据</h2><p><strong>master主要存储三种元数据：</strong></p><ol><li>文件和chunk命名空间</li><li>文件到chunk的映射</li><li>每个chunk的副本的位置</li></ol><p>第一个和第二个类型业户通过改变存储在master本地磁盘和副本的operation log来保护持久化。</p><p>master不会持久存储chunk位置信息。当master启动或者chunkserver加入集群中，master会询问每个chunkserver关于chunk的信息</p><h3 id="内存中的数据结构"><a class="markdownIt-Anchor" href="#内存中的数据结构"></a> 内存中的数据结构</h3><p>因为一些元数据存储在内存，master的操作很快。同时，对于master更加轻松和有效率在后台去检查整个状态。定期检查用来chunk垃圾回收，当chunkserver的再复制，chunk的迁移去均衡chunkserver的负载和磁盘空间。</p><p>这种只使用内存的方法的一个潜在问题是，chunk的数量以及整个系统的容量都受到master所拥有的内存的限制。在实践中并不是一个严重的限制。master为每个64MB的chunk维持一个不到64bite的状态。大多数chunk都是满的，因为大多数文件包含许多块，只有最后一个hunk可能部分被填满。同样地，文件名称空间数据通常需要每个文件少于64字节，因为它使用前缀压缩来存储文件名。</p><p>如果有必要支持更大的文件系统，那么向master添加额外内存的成本与将元数据存储在内存中所获得的简单性、可靠性、性能和灵活性相比是很小的代价。</p><h3 id="chunk位置"><a class="markdownIt-Anchor" href="#chunk位置"></a> chunk位置</h3><p>对于一个chunk，存储其副本的chunkserver的信息不会持久存储在master中。master仅仅在启动时，轮训访问chunkserver来获取相关信息。因为master通过心跳信息来控制所有chunk的位置和监控chunkserver状态，所以master可以保持最新状态。</p><p>之所以不用持久存储，是因为chunkserver的chunk可能会消失。因此持久存储没有意义</p><h3 id="operation-log"><a class="markdownIt-Anchor" href="#operation-log"></a> operation log</h3><p>operation log包含改变重要元数据的历史记录，对GFS十分关键。不仅仅是因为他是元数据的唯一持久化存储，并且他可以作为逻辑时间线来定义并发操作的顺序。</p><p>文件，chunk和他们的版本号都是独一无二的，不变的，他们都由他们被创建的逻辑时间定义</p><p>operation log很重要，我们必须可靠存储它，直到元数据更改被持久化之前，对client不可见。否则，即使chunk存在，我们也会失去整个文件系统和最新的client操作。因此，我们将其复制在另一个遥远的机器上，仅在本地和远处机器将相应的operation log写到磁盘后，再相应client的操作。master在刷新之前将多个log一起处理，从而减少了刷新和拷贝对整个系统吞吐量的影响。</p><p>master通过重演operation log来恢复文件系统状态。为了最小化启动时间，我们必须保持log最小。无论何时，当opetaion log的大小超过一定大小，master对其状态设置检查点，因此master可以通过从磁盘加载最近的检查点，仅仅重演在检查点之后的一部分operaton log的一系列操作来恢复状态。检查点是一种紧凑的类似b树的形式，可以直接映射到内存中，并用于名称空间查找，而不需要额外的解析，大大加快了恢复的速度和提高了可用性。</p><p>创建检查点需要耗费时间，为了不延迟即将要来的操作，master在另一个进程切换到一个新的log，并且创建一个新的检查点，新的检查点包括切换之前的所有信息。对于 一个百万机器的集群，需要花费一分钟。完成后，会写入本地和远处的磁盘</p><p>重新恢复仅仅需要最近的检查点和其之后的log文件。更好的检查点和log文件可以自由删除，但也可以保存一些以免别的意外。检查点期间的失败不会影响正确性，因为恢复代码会检测并跳过不完整的检查点</p><h2 id="一致性模型"><a class="markdownIt-Anchor" href="#一致性模型"></a> 一致性模型</h2><p>GFS是一个弱一致性模型，可以很好支持我们分布式应用，同时实现更好简单和有效率。我们会讨论GFS的保证和他们对应用意味着什么。我们也强调GFS如何维持这些保证。</p><h3 id="gfs的保证"><a class="markdownIt-Anchor" href="#gfs的保证"></a> GFS的保证</h3><p>文件命名空间的改变（比如文件的创建）是原子的。他们完全由master处理。命名空间锁保证了原子性和正确性，master的operation log定义了这些操作的全局顺序。</p><p>在数据更改后，文件区域的状态取决了更改的种类，是否成功，是否有并发改变。如下图</p><p>![](/Users/yixuanyan/Library/Application Support/typora-user-images/image-20210818202807439.png)</p><p>consistent：不管client从那个副本读，都是相通的</p><p>defined：他是consistent的，并且client会知道改变了什么。当一个改变成功，且没有收到并发写的影响，该区域就是defined，所有的client都会看到改变写了什么。</p><p>undefined but consistent：client看到的数据相同，但是不会看到条目中写了什么。当多个改变成功，不同于defined是他是多个改变，defined是一个改变。</p><p>inconsistent：不同的client在不同的时间看到不同的数据。是一个失败的改变导致。</p><p><strong>数据的更改主要是写和追加</strong></p><p>写是在应用指定文件的偏移量上写入数据。追加是在文件末尾至少原子性写入一次数据。</p><p>在一系列成功的改变后，被改变的文件保证是defined，并且包含文件最后一次更改的数据。步骤如下：</p><ol><li>以相同的顺序对chunk所在的副本进行改变</li><li>用chunk版本号去发现所有的陈旧的副本，因为这些chunkserver可能会因为宕机导致更改丢失</li></ol><p>陈旧的副本不会再涉及到更改，或者给询问master的client以位置信息。他们是最早回收的垃圾</p><p>因为client缓存chunk的位置，他们可以从陈旧的副本中读取如果相关信息没来得及刷新。这中情况会受到缓存超时和下一次打开文件的限制，这些会导致缓存清楚该文件所有的相关信息。此外，大多数文件是追加，这时，陈旧的副本返回的不是过时数据，而是不完整的数据。当一个读条目请求master时，会立即得到当前chunk的位置</p><p>在改变成功后，部件失败导致数据损坏的情况同样可能发生。GFS通过在master和所有的chunkserver握手来发现失败的chunkserver，并且通过校验和检查是否数据损坏。一旦问题发生，数据会尽快从好的副本中重新存储。一个chunk只有在GFS得以反应之前，所有的副本chunk都丢失，该chunk的丢失才不可逆。即使这样，他也只是不可用，而不是损坏。应用接收到的错误是error而不是损坏数据。</p><h3 id="应用的影响"><a class="markdownIt-Anchor" href="#应用的影响"></a> 应用的影响</h3><h1 id="系统交互"><a class="markdownIt-Anchor" href="#系统交互"></a> 系统交互</h1><p>我们要使master在操作中花费的成本最小，在此背景下，来讨论client，chunkserver，master如何交互来完成数据改变，原子记录追加，快照。</p><h2 id="租贷和mutation命令"><a class="markdownIt-Anchor" href="#租贷和mutation命令"></a> 租贷和mutation命令</h2><p>上文都是将mutation翻译成改变，但是感觉不是很符合原文的意思，于是还是不翻译mutation了</p><p>mutation是改变chunk元数据的内容，比如写数据或者追加操作。每个mutation都在chunk的所有副本上进行。我们使用租贷leash来维持所有副本间的一致性mutation顺序。</p><p>master将一个chunk租给副本中的一个，我们称之为primary。primary为chunk的mutation选择一个序列顺序。所有的副本在进行mutation时，按照这个顺序，</p><p>租贷机制是为了减少master的管理负载。租贷最初是60秒超时。primary可以无限地向master请求或者接受扩展。</p><p>过程如下图</p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/uPic/WH2Zfh.png" alt="" /></p><ol><li>client询问master哪个chunkserver有当前chunk的租贷，并且当前chunk的其他副本。如果没有租贷，master会命名给一个副本。    <strong>ps：client向master询问primary和secondary</strong></li><li>master返回primart的标识符和其他secondary的位置。client缓存这些信息。client不需要在请求master，知道发现primary不可达，或者primary不再是primary。</li><li>client让数据发送到所有的副本。每个副本将数据存储到一个LRU缓冲区，直到数据被使用或者老化。通过将数据流和控制流解偶，可以提高网络拓扑，无论那个chunkserver是primary。</li><li>一旦所有的副本承认接收到了数据，client发送一个写请求给primary。该请求包括了之前发送到所有数据的标识。primary分配给这些标识符一个序列（这些标识符可能来自于多个client），这样保持了必要的串行。然后在本地上以这些序列来进行mutation</li><li>primary发送写请求给所有secondary副本。每个secondary使用和master分配的mutation序列。</li><li>secondary会回复primary他们完成所有操作</li><li>primary回复client。在任何副本发生的error都会报告给client。在有error的情况下，写操作在primary和任意部分secondary成功完成。（如果在primary操作出现error，咋不会给mutation分配序列同时发送给secondary）。如果出现失败，则client会选择重试，按照step3-step7.</li></ol><p>如果来自应用的写太大，超过了chunk的大小，GFSclient会把它切割成多个写操作。</p><h1 id="master的操作"><a class="markdownIt-Anchor" href="#master的操作"></a> master的操作</h1><p>master执行所有命名空间的操作。同时通过系统管理chunk的副本，做出放置决策，创建新的chunk和副本，协调各种系统工作区保证块的完全复制，平衡chunkserver的负载，回收没使用的存储</p><h2 id="命名空间管理和锁"><a class="markdownIt-Anchor" href="#命名空间管理和锁"></a> 命名空间管理和锁</h2><h2 id="副本置换"><a class="markdownIt-Anchor" href="#副本置换"></a> 副本置换</h2><p><strong>两个目的</strong></p><ol><li>最大化数据可靠性和可用性</li><li>最大化网络宽带的利用</li></ol><h2 id="复制再拷贝再平衡"><a class="markdownIt-Anchor" href="#复制再拷贝再平衡"></a> 复制，再拷贝，再平衡</h2><p><strong>chunk副本的创建有三种方式：</strong></p><ol><li>chunk创建</li><li>chunk再拷贝</li><li>chunk再平衡</li></ol><p>创建chunk时，需要考虑几点因素</p><ol><li>希望创建的chunkserver的空间利用率在平均值一下</li><li>希望限制一个chunkserver再一段时间内创建chunk的次数</li><li>希望将chunk副本分布在多个rack上</li></ol><p><strong>再复制</strong>：当chunk副本的数量小于用户目标时</p><ol><li>chunkserver不可用</li><li>chunkserver的磁盘坏了</li><li>用户的复制需求增加</li></ol><p><strong>再平衡：</strong></p><ol><li>平衡磁盘利用率</li><li>限制单一chunkserver的复制次数</li><li>平衡rack的副本</li></ol><h2 id="垃圾回收"><a class="markdownIt-Anchor" href="#垃圾回收"></a> 垃圾回收</h2><p>当文件被删除时，并不直接通知其副本，而是在垃圾回收的时候通知。</p><h3 id="机制"><a class="markdownIt-Anchor" href="#机制"></a> 机制</h3><p>当文件删除时，master记录delete命令，但是并不通知其副本，文件被命名为一个隐藏名字，其中包括了删除时间戳。当master定期检查文件系统命名空间时，会移除超过三天的隐藏名字（其中天数可以配置）。在此期间，文件还是可以根据这个新名字来读，如果想不删除，将名字改回正常即可。当文件从命名空间删除，他的元数据也删除。</p><p>在遍历chunk命名空间时，master也会标记孤儿chunk，并且抹去这些chunk的元数据。</p><p>在chunkserver和master的心跳信息中，chunkserver汇报他拥有的chunk，master回复那些不再存储元数据的chunk标记，这时候，chunkserver可以自由删除这些chunk的副本。</p><p><strong>该机制的优点：</strong></p><ol><li>在大型分布式系统中简单可靠</li><li>将多个命令合并成一个定期的命名空间的遍历和chunkserver的握手</li><li>延迟删除可以提供了网络安全，放置不可逆的删除</li></ol><p><strong>缺点：</strong></p><ol><li>当存储空间比较少的时候，延迟延迟会影响用户的使用，用户的重复创建，删除可能不能很好的复用空间。</li><li>解决方法，可以让用户标记不同的复制策略，比如用户可以标记一些目录的chunk不需要副本，这样删除文件可以直接删除，并且不可逆</li></ol><h2 id="过期副本检测"><a class="markdownIt-Anchor" href="#过期副本检测"></a> 过期副本检测</h2><p>有时候chunk副本可能会过期，因为chunkserver没有执行相关命令。因此，对于每个chunk，master都维护一个chunk版本号来分别最新chunk和过期chunk</p><p>当给一个租贷给chunk时，会增加chunk的版本好，并且通知最新的chunk。master和所有副本都会在持久状态中记录最新的版本号。如果一个chunkserver因为异常，没有执行命令，他的版本号不会增加，让他重启或者重新发送他的chunk序列及其版本号时，master就会发现过期的chunk。如果master发现最新的版本号大于记录的版本号，master就会假设分配租贷的时候失败，所以会更新一个更高的版本号。</p><p>master在垃圾回收的时候，移除过期的副本，并且在回复给client请求chunk信息时，当作过期的副本不存在。还有一种保护方法，当master回复client什么chunkserver拥有什么chunk的租贷时，或者什么时候让一个chunkserver去读取另一个chunkserver的副本时，会包含版本号，这样client和chunkserver总是会读到最新的数据。</p><h1 id="容错和诊断"><a class="markdownIt-Anchor" href="#容错和诊断"></a> 容错和诊断</h1><p>设计系统最大的挑战就是频繁的组建故障。组件的质量和数量使得异常频出，我们不能完全相信机器，我们也不能完全相信磁盘。</p><h2 id="高可用性"><a class="markdownIt-Anchor" href="#高可用性"></a> 高可用性</h2><p>通过两个策略保证可用性</p><ol><li>快恢复</li><li>复制</li></ol><h3 id="快恢复"><a class="markdownIt-Anchor" href="#快恢复"></a> 快恢复</h3><p>不管master和chunkserver为什么终止，都会在几秒内重新启动并且恢复状态。实际上，我们不区分正常异常和不正常异常</p><h3 id="chunk副本"><a class="markdownIt-Anchor" href="#chunk副本"></a> chunk副本</h3><p>master会通过校验和来检查坏的副本或者当chunkserver下线时，master会克隆新的副本出来。</p><h3 id="master副本"><a class="markdownIt-Anchor" href="#master副本"></a> master副本</h3><p>master的副本是为了master的可用性。master的operation log和检查点都保存在别的机器上。只有在所有的记录日志写入到磁盘和其他机器上，master才可以继续完成需要改变状态的命令。</p><p>如果master的机器或者磁盘损坏，GFS的监控部件会重新启动一个新的master进程。client只知道master的名字，因此master可以通过改变DNS的绰号来切换到另一个机器。</p><p>其次，当master损坏时，由影子master（shadow master）来访问文件系统，但是影子master只有可读权限。</p><p>影子master会比masteer处理慢一些。但是他们增强了对文件的可读操作，那些文件不会经常改变或者client不建议得到过期的文件。</p><p>为了使自己了解系统的情况，影子master会读取operation log，并且执行改变数据的相同序列，使得行为与master完全一致。和master一样，在启动时会轮训chunkserver来定位chunk副本的位置，并且频繁的chunkserver握手来监控他们的状态。对于副本的深处或者更新仅仅依赖master</p><h2 id="数据一致性"><a class="markdownIt-Anchor" href="#数据一致性"></a> 数据一致性</h2><p>每个chunkserver通过校验和去检查数据是否一致。</p><p>在chunkserver相应client或者master的请求时，都会校验一下数据block。因此，chunkserver不会把坏数据传播给其他机器。受到相应后，请求者会读取别的副本，而master也会读取副本，并且复制，之后给chunkserver发送消息，通知其删除错误副本。</p><h1 id="结尾"><a class="markdownIt-Anchor" href="#结尾"></a> 结尾</h1><p>基本的概念就结束了，后面就是一些测试和结论，就懒得记笔记了。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本文是对谷歌论文：The Google File System的笔记&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作者：Sanjay Ghemawat, Howard Gobioff, and Shun-Tak Leung Google∗&lt;/strong</summary>
      
    
    
    
    <category term="分布式系统" scheme="https://mryanhehe.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="分布式系统" scheme="https://mryanhehe.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="文件系统" scheme="https://mryanhehe.github.io/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
