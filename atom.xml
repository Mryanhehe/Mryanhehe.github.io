<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mr言的博客</title>
  
  <subtitle>记录点滴</subtitle>
  <link href="https://www.mryan.cool/atom.xml" rel="self"/>
  
  <link href="https://www.mryan.cool/"/>
  <updated>2021-06-01T06:40:31.480Z</updated>
  <id>https://www.mryan.cool/</id>
  
  <author>
    <name>严轶轩</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://www.mryan.cool/2021/06/01/1-1/"/>
    <id>https://www.mryan.cool/2021/06/01/1-1/</id>
    <published>2021-06-01T06:40:31.480Z</published>
    <updated>2021-06-01T06:40:31.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="练习1：理解通过make生成执行文件的过程"><a href="#练习1：理解通过make生成执行文件的过程" class="headerlink" title="练习1：理解通过make生成执行文件的过程"></a>练习1：理解通过make生成执行文件的过程</h1><h2 id="练习1-1-解释Makefile命令"><a href="#练习1-1-解释Makefile命令" class="headerlink" title="练习1.1:解释Makefile命令"></a>练习1.1:解释Makefile命令</h2><p>通常make之后输出输出，不会显示执行过程，我们可以用make “V=”</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//编译init.c文件，生成init.o</span><br><span class="line">+ cc kern/init/init.c</span><br><span class="line">  gcc -Ikern/init/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/init/init.c -o obj/kern/init/init.o</span><br><span class="line"></span><br><span class="line">//编译stdio.c，生成stdio.o</span><br><span class="line">+ cc kern/libs/stdio.c</span><br><span class="line">  gcc -Ikern/libs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/libs/stdio.c -o obj/kern/libs/stdio.o</span><br><span class="line">  </span><br><span class="line">//编译readline.c生成readline.o</span><br><span class="line">+ cc kern/libs/readline.c</span><br><span class="line">  gcc -Ikern/libs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/libs/readline.c -o obj/kern/libs/readline.o</span><br><span class="line">  </span><br><span class="line">//编译panic.c，生成panic.o</span><br><span class="line">+ cc kern/debug/panic.c</span><br><span class="line">  gcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/panic.c -o obj/kern/debug/panic.o</span><br><span class="line"></span><br><span class="line">//编译kdedebug</span><br><span class="line">+ cc kern/debug/kdebug.c</span><br><span class="line">  gcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/kdebug.c -o obj/kern/debug/kdebug.o</span><br><span class="line">+ cc kern/debug/kmonitor.c</span><br><span class="line">  gcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/kmonitor.c -o obj/kern/debug/kmonitor.o</span><br><span class="line">+ cc kern/driver/clock.c</span><br><span class="line">  gcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/clock.c -o obj/kern/driver/clock.o</span><br><span class="line">+ cc kern/driver/console.c</span><br><span class="line">  gcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/console.c -o obj/kern/driver/console.o</span><br><span class="line">+ cc kern/driver/picirq.c</span><br><span class="line">  gcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/picirq.c -o obj/kern/driver/picirq.o</span><br><span class="line">+ cc kern/driver/intr.c</span><br><span class="line">  gcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/intr.c -o obj/kern/driver/intr.o</span><br><span class="line">+ cc kern/trap/trap.c</span><br><span class="line">  gcc -Ikern/trap/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/trap.c -o obj/kern/trap/trap.o</span><br><span class="line">+ cc kern/trap/vectors.S</span><br><span class="line">  gcc -Ikern/trap/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/vectors.S -o obj/kern/trap/vectors.o</span><br><span class="line">+ cc kern/trap/trapentry.S</span><br><span class="line">  gcc -Ikern/trap/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/trapentry.S -o obj/kern/trap/trapentry.o</span><br><span class="line">+ cc kern/mm/pmm.c</span><br><span class="line">  gcc -Ikern/mm/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/mm/pmm.c -o obj/kern/mm/pmm.o</span><br><span class="line">+ cc libs/string.c</span><br><span class="line">  gcc -Ilibs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/  -c libs/string.c -o obj/libs/string.o</span><br><span class="line">+ cc libs/printfmt.c</span><br><span class="line">  gcc -Ilibs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/  -c libs/printfmt.c -o obj/libs/printfmt.o</span><br><span class="line">  </span><br><span class="line">//链接生成目标文件，生成kernel二进制文件</span><br><span class="line">+ ld bin/kernel</span><br><span class="line">  ld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/stdio.o obj/kern/libs/readline.o obj/kern/debug/panic.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/picirq.o obj/kern/driver/intr.o obj/kern/trap/trap.o obj/kern/trap/vectors.o obj/kern/trap/trapentry.o obj/kern/mm/pmm.o  obj/libs/string.o obj/libs/printfmt.o</span><br><span class="line">  </span><br><span class="line">  //编译bootasm.s，bootmain.c,sign.c文件</span><br><span class="line">+ cc boot/bootasm.S</span><br><span class="line">  gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o</span><br><span class="line">+ cc boot/bootmain.c</span><br><span class="line">  gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o</span><br><span class="line">+ cc tools/sign.c</span><br><span class="line">  gcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.o</span><br><span class="line">  gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign</span><br><span class="line">  </span><br><span class="line">  链接生成bootblock二进制文件</span><br><span class="line">+ ld bin/bootblock</span><br><span class="line">  ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o</span><br><span class="line">  &#x27;obj/bootblock.out&#x27; size: 488 bytes</span><br><span class="line">  build 512 bytes boot sector: &#x27;bin/bootblock&#x27; success!</span><br><span class="line">  </span><br><span class="line">  //生成ucore.img文件，大小为10000个块，一个块默认512字节</span><br><span class="line">  dd if=/dev/zero of=bin/ucore.img count=10000</span><br><span class="line">  dd if=bin/bootblock of=bin/ucore.img conv=notrunc</span><br><span class="line">  dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc</span><br></pre></td></tr></table></figure><h2 id="1-2-一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"><a href="#1-2-一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？" class="headerlink" title="1.2 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"></a>1.2 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</h2><p><strong>主引导扇区</strong>：硬盘的0柱面、0磁头、1扇区称为<a href="https://baike.baidu.com/item/%E4%B8%BB%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA">主引导扇区</a>，也叫<a href="https://baike.baidu.com/item/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95">主引导记录</a><a href="https://baike.baidu.com/item/MBR/10473976">MBR</a>，该记录占用512个字节，它用于硬盘启动时将系统控制权转给用户指定的、在分区表中登记了某个<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192">操作系统</a>分区，并且最后两个字节是0x55AA。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;练习1：理解通过make生成执行文件的过程&quot;&gt;&lt;a href=&quot;#练习1：理解通过make生成执行文件的过程&quot; class=&quot;headerlink&quot; title=&quot;练习1：理解通过make生成执行文件的过程&quot;&gt;&lt;/a&gt;练习1：理解通过make生成执行文件的过程&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>flutter-登录(accesstoken和refreshtoken)</title>
    <link href="https://www.mryan.cool/2021/02/22/flutter-%E7%99%BB%E5%BD%95(accesstoken%E5%92%8Crefreshtoken)/"/>
    <id>https://www.mryan.cool/2021/02/22/flutter-%E7%99%BB%E5%BD%95(accesstoken%E5%92%8Crefreshtoken)/</id>
    <published>2021-02-22T07:30:44.000Z</published>
    <updated>2021-02-22T08:01:00.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="accesstoken和refreshtoken"><a href="#accesstoken和refreshtoken" class="headerlink" title="accesstoken和refreshtoken"></a>accesstoken和refreshtoken</h1><p>在实现flutter的拦截登录的时候遇到点困难，记得客户端和服务端的传递依靠token，于是百度了一下</p><h2 id="1-token化的协议过程"><a href="#1-token化的协议过程" class="headerlink" title="1:token化的协议过程"></a>1:token化的协议过程</h2><p><img src="https://img-blog.csdn.net/20180629135828686?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNjAwMDE5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><h1 id="2-accesstoken、refreshtoken"><a href="#2-accesstoken、refreshtoken" class="headerlink" title="2:accesstoken、refreshtoken"></a>2:accesstoken、refreshtoken</h1><p>access token 是在 Oauth2.0 协议中，客户端访问资源服务器的令牌（其实就是一段全局唯一的随机字符串）。拥有这个令牌代表着得到用户的授权。它里面包含哪些信息呢？答案是：</p><p>　　<strong>哪个用户 在什么时候 授权给哪个客户端 去做什么事情</strong></p><p>网上找到一个Oauth2.0的文章：<a href="https://www.cnblogs.com/blowing00/p/4521135.html">简单介绍 Oauth2.0 原理</a></p><p>但是这个授权可以被泄露，所以这个授权有一定有效期。但是如果每次过期后都需要重新授权，会使得用户体验感下降，于是引入了refreshtoken。refresh token 的作用是用来刷新 access token。鉴权服务器提供一个刷新接口，例如：</p><blockquote><p>POST /refresh</p><p>　　　参数： refreshtoken</p><p>　　　返回：新的 access token</p></blockquote><p>传入 refresh token，鉴权服务器验证通过后，返回一个新的 access token。为了安全，Oauth2.0 引入了两个措施：</p><p>　　1，Oauth2.0 要求，refresh token 一定是保存在服务器上（应用方的服务器）的，而绝不能存放在狭义的客户端（例如移动 app、PC端软件、浏览器） 上。调用 refresh 接口的时候，一定是从服务器到服务器的访问；</p><p>　　2，Oauth2.0 引入了 client_id 、client_secret 机制。即每一个应用都会被分配到一个 client_id 和一个对应的 client_secret。应用必须把 client_secret 妥善保管在服务器上，决不能泄露。刷新 access token 时，需要验证这个 client_secret。</p><p>　　于是，实际上的刷新接口应该是类似这样的：</p><blockquote><p>POST /refresh</p><p>　　　参数：</p><p>　　　　refresh token</p><p>　　　　client_id</p><p>　　　　signatrue 签名，由 sha256(client_id + refresh_token + client_secret) 得到</p><p>　　　返回：新的 access token</p></blockquote><p>于是我们可以得知，当access_token，APP使用refresh_token来刷新token，但如果refresh_token，就需要用户重新登录。</p><h3 id="登录逻辑"><a href="#登录逻辑" class="headerlink" title="登录逻辑"></a>登录逻辑</h3><h4 id="添加token"><a href="#添加token" class="headerlink" title="添加token"></a>添加token</h4><ul><li><strong>登录成功，保存token到本地</strong>，转跳到首页，移除其他栈，防止返回回到登录页面</li></ul><h4 id="移除token"><a href="#移除token" class="headerlink" title="移除token"></a>移除token</h4><ul><li><strong>未登录</strong> 路由拦截找不到token，转跳到登录页面或者弹窗</li><li><strong>token过期</strong>，后台返回token，api拦截，移除token，转跳到登录页面</li><li><strong>退出登录</strong>移除token，转跳到登录页面，移除前面所有路由栈</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;accesstoken和refreshtoken&quot;&gt;&lt;a href=&quot;#accesstoken和refreshtoken&quot; class=&quot;headerlink&quot; title=&quot;accesstoken和refreshtoken&quot;&gt;&lt;/a&gt;accesstoken和re</summary>
      
    
    
    
    <category term="flutter" scheme="https://www.mryan.cool/categories/flutter/"/>
    
    
    <category term="flutter" scheme="https://www.mryan.cool/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>计算两个字符串的距离</title>
    <link href="https://www.mryan.cool/2020/08/03/%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%B7%9D%E7%A6%BB/"/>
    <id>https://www.mryan.cool/2020/08/03/%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%B7%9D%E7%A6%BB/</id>
    <published>2020-08-03T12:47:16.000Z</published>
    <updated>2020-08-03T13:15:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于不同的字符串，我们希望能有办法判断相似程度，我们定义了一套操作方法来把两个不相同的字符串变得相同，具体的操作方法如下：</p><p>1 修改一个字符，如把“a”替换为“b”。</p><p>2 增加一个字符，如把“abdd”变为“aebdd”。</p><p>3 删除一个字符，如把“travelling”变为“traveling”。</p><p>比如，对于“abcdefg”和“abcdef”两个字符串来说，我们认为可以通过增加和减少一个“g”的方式来达到目的。上面的两种方案，都只需要一次操作。把这个操作所需要的次数定义为两个字符串的距离，而相似度等于“距离＋1”的倒数。也就是说，“abcdefg”和“abcdef”的距离为1，相似度为1/2=0.5.</p><p>给定任意两个字符串，你是否能写出一个算法来计算出它们的相似度呢？</p><p>请实现如下接口</p><p> /* 功能：计算字符串的相似度<br> * 输入：pucAExpression/ pucBExpression：字符串格式，如: “abcdef”<br> * 返回：字符串的相似度,相似度等于“距离＋1”的倒数,结果请用1/字符串的形式,如1/2<br> <em>/<br> public static String calculateStringDistance(String expressionA, String expressionB)<br> {<br>   /</em> 请实现*/<br>   return null;<br> }</p><p>约束：</p><p>1、PucAExpression/ PucBExpression字符串中的有效字符包括26个小写字母。</p><p>2、PucAExpression/ PucBExpression算术表达式的有效性由调用者保证;<br>3、超过result范围导致信息无法正确表达的，返回null。</p><h2 id="算法设计思想"><a href="#算法设计思想" class="headerlink" title="算法设计思想"></a>算法设计思想</h2><p>编辑距离的作用主要是用来比较两个字符串的相似度的</p><p>基本的定义如下所示：</p><p><strong>编辑距离</strong>，又称Levenshtein距离（莱文斯坦距离也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数，如果它们的距离越大，说明它们越是不同。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。</p><p>这个概念是由俄罗斯科学家Vladimir Levenshtein在1965年提出来的，所以也叫 Levenshtein 距离。它可以用来做DNA分析，拼字检测，抄袭识别等等。总是比较相似的，或多或少我们可以考虑编辑距离。</p><p>在概念中，我们可以看出一些重点那就是，编辑操作只有三种。插入，删除，替换这三种操作，我们有两个字符串，将其中一个字符串经过上面的这三种操作之后，得到两个完全相同的字符串付出的代价是什么就是我们要讨论和计算的。</p><p>例如：<br>我们有两个字符串： kitten 和 sitting:<br>现在我们要将kitten转换成sitting<br>我们可以做如下的一些操作；</p><p>k i t t e n –&gt; s i t t e n 将K替换成S</p><p>sitten –&gt; sittin 将 e 替换成i</p><p>sittin –&gt; sitting 添加g</p><p>在这里我们设置每经过一次编辑，也就是变化（插入，删除，替换）我们花费的代价都是1。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于不同的字符串，我们希望能有办法判断相似程度，我们定义了一套操作方法来把两个不相同的字符串变得相同，具体的操作方法如下：&lt;/p&gt;
&lt;p&gt;1 修改一个字符，如把“a”替换为“b”。&lt;/p&gt;
&lt;p&gt;2 增加一个字符，如把“abdd”变为“aebdd”。&lt;/p&gt;
&lt;p&gt;3 删除</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>复旦大学计算机拟录取名单分析</title>
    <link href="https://www.mryan.cool/2020/07/18/%E5%A4%8D%E6%97%A6%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8B%9F%E5%BD%95%E5%8F%96%E6%88%90%E7%BB%A9%E5%88%86%E6%9E%90/"/>
    <id>https://www.mryan.cool/2020/07/18/%E5%A4%8D%E6%97%A6%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8B%9F%E5%BD%95%E5%8F%96%E6%88%90%E7%BB%A9%E5%88%86%E6%9E%90/</id>
    <published>2020-07-18T11:16:36.000Z</published>
    <updated>2020-07-18T14:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="复旦大学计算机拟录取名单分析"><a href="#复旦大学计算机拟录取名单分析" class="headerlink" title="复旦大学计算机拟录取名单分析"></a>复旦大学计算机拟录取名单分析</h1><p><strong>复旦大学是考研的目标院校，最近名单下来了，决定对名单进行一下数据分析</strong>。</p><h2 id="第一步：信息获取"><a href="#第一步：信息获取" class="headerlink" title="第一步：信息获取"></a>第一步：信息获取</h2><p>复旦大学的信息获取，我是自己写了一个脚本，源代码再次。该脚本可以发现复旦大学新出的消息，并向邮件发送，保证自己掌握第一手消息。</p><p>话不多说，直接上数据。<a href="http://www.gsao.fudan.edu.cn/b4/08/c15014a242696/page.htm">复旦大学拟录取名单</a>。</p><p>下载官网数据。</p><h2 id="第二步：数据文件处理"><a href="#第二步：数据文件处理" class="headerlink" title="第二步：数据文件处理"></a>第二步：数据文件处理</h2><p>下载的文件是pdf，所以我们先将pdf中的文字提取出来，利用pandas库分析。</p><p>我才用的库是pdfplumber。该库是一个专门用于pdf数据分析的库，识别率还比较满意。</p><p>先将每页的数据转成DataFrame。（我们只需要计算机的，因此只提取了20到40页）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pdfplumber</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">pages = []</span><br><span class="line">df_list = []</span><br><span class="line"><span class="keyword">with</span> pdfplumber.<span class="built_in">open</span>(<span class="string">&quot;复旦.pdf&quot;</span>) <span class="keyword">as</span> pdf:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>,<span class="number">40</span>):</span><br><span class="line">            pages.append(pdf.pages[i])</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> pages:</span><br><span class="line">        <span class="keyword">for</span> table <span class="keyword">in</span> page.extract_tables(): </span><br><span class="line">            <span class="comment">#得到的table是嵌套list类型，转化成DataFrame更加方便查看和分析 </span></span><br><span class="line">            df_list.append(pd.DataFrame(table[<span class="number">1</span>:], columns=table[<span class="number">0</span>]))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>pdf文件的索引一般在第一页，我们提取的是20到40页，因此每页的所以都是第一行，在之后的合并中会产生bug，因此我们先把每个DataFrame的索引改一下。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> df <span class="keyword">in</span> df_list:</span><br><span class="line">    df.columns=[<span class="string">&#x27;考生编号&#x27;</span>,<span class="string">&#x27;姓名&#x27;</span>,<span class="string">&#x27;院系&#x27;</span>,<span class="string">&#x27;初始成绩&#x27;</span>,<span class="string">&quot;复试成绩&quot;</span>,<span class="string">&#x27;总成绩&#x27;</span>,<span class="string">&#x27;备注&#x27;</span>] </span><br></pre></td></tr></table></figure><p>现在就可以将每页的DataFrame合并了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.concat(df_list,axis=<span class="number">0</span>,sort = <span class="literal">False</span>)</span><br><span class="line">df</span><br><span class="line">df_list[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="第三步：数据过滤及处理"><a href="#第三步：数据过滤及处理" class="headerlink" title="第三步：数据过滤及处理"></a>第三步：数据过滤及处理</h2><p>筛选出院系是计算机科学技术学院的名单。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">computer = df.loc[df[<span class="string">&#x27;院系&#x27;</span>] == <span class="string">&#x27;计算机科学技术学院&#x27;</span>]</span><br><span class="line">df.count()</span><br></pre></td></tr></table></figure><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200718192656.png"></p><p>对成绩等信息进行类型转换</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">computer[[<span class="string">&#x27;初始成绩&#x27;</span>,<span class="string">&quot;复试成绩&quot;</span>,<span class="string">&#x27;总成绩&#x27;</span>]] = computer[[<span class="string">&#x27;初始成绩&#x27;</span>,<span class="string">&quot;复试成绩&quot;</span>,<span class="string">&#x27;总成绩&#x27;</span>]].apply(pd.to_numeric)</span><br><span class="line">computer.dtypes</span><br></pre></td></tr></table></figure><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200718194728.png"></p><p>对成绩等信息进行分析</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">computer[[<span class="string">&#x27;初始成绩&#x27;</span>,<span class="string">&quot;复试成绩&quot;</span>,<span class="string">&#x27;总成绩&#x27;</span>]].describe()</span><br></pre></td></tr></table></figure><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200718194839.png"></p><p>果然如对面所说，去年复试线310，刚好有一个人考了310，于是好奇去看了一下他的信息。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">computer.loc[computer[<span class="string">&#x27;初始成绩&#x27;</span>] == <span class="number">310</span>]</span><br></pre></td></tr></table></figure><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200718195126.png"></p><p>emmm,这个人的复试成绩这么高。。。难怪可以310进去。。。。。</p><p>对初试成绩，复试成绩，总成绩进行分数段统计</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">computer[[<span class="string">&#x27;初始成绩&#x27;</span>,<span class="string">&quot;复试成绩&quot;</span>,<span class="string">&#x27;总成绩&#x27;</span>]] = computer[[<span class="string">&#x27;初始成绩&#x27;</span>,<span class="string">&quot;复试成绩&quot;</span>,<span class="string">&#x27;总成绩&#x27;</span>]].apply(pd.to_numeric)</span><br><span class="line">res = pd.cut(computer[<span class="string">&#x27;初始成绩&#x27;</span>] , [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">310</span>,<span class="number">420</span>,<span class="number">10</span>)],right = <span class="literal">False</span>,labels= [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">310</span>,<span class="number">410</span>,<span class="number">10</span>)])</span><br><span class="line">computer[<span class="string">&#x27;初始分数段&#x27;</span>] = res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res = pd.cut(computer[<span class="string">&#x27;复试成绩&#x27;</span>] ,[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">60</span>,<span class="number">100</span>,<span class="number">5</span>)],right = <span class="literal">False</span>,labels= [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">60</span>,<span class="number">95</span>,<span class="number">5</span>)])</span><br><span class="line"><span class="built_in">list</span>(res)</span><br><span class="line">computer[<span class="string">&#x27;复试分数段&#x27;</span>] = res</span><br><span class="line"></span><br><span class="line">res = pd.cut(computer[<span class="string">&#x27;总成绩&#x27;</span>],[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">60</span>,<span class="number">90</span>,<span class="number">5</span>)],right = <span class="literal">False</span> ,labels= [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">60</span>,<span class="number">85</span>,<span class="number">5</span>)])</span><br><span class="line"><span class="built_in">list</span>(res)</span><br><span class="line">computer[<span class="string">&#x27;总成绩分数段&#x27;</span>] = res</span><br></pre></td></tr></table></figure><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200718211843.png"></p><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><p><strong>初始分数段柱状图</strong></p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/下载 (2).png" style="zoom:150%;" /><p><strong>初试分数段饼图</strong></p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/xiazai9.png"></p><p><strong>复试分数段柱状图</strong></p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E4%B8%8B%E8%BD%BD.png"></p><p><strong>复试分数段饼图</strong></p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/下载 (8).png"  /><p><strong>总成绩分数段柱状图</strong></p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/xiazai20.png"></p><p><strong>总成绩分数段饼图</strong></p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/xiazai21.png"></p><p>最终成绩，大部分都是在70-80之间，根据复试和总成绩来看，不难看到复试的相对给分还是比较高的。得益于今年的扩招，复试的分数线有50%的人都在360以下。这个上岸的几率还是蛮大的。</p><p><strong>总成绩前20和倒数20的对比</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">min_stu = computer.sort_values([<span class="string">&#x27;总成绩&#x27;</span>]).iloc[:<span class="number">20</span>]</span><br><span class="line">max_stu = computer.sort_values([<span class="string">&#x27;总成绩&#x27;</span>],ascending=[<span class="literal">False</span>]).iloc[:<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line">plt.scatter(max_stu[<span class="string">&#x27;初始成绩&#x27;</span>],max_stu[<span class="string">&#x27;复试成绩&#x27;</span>],color=<span class="string">&#x27;green&#x27;</span>, label=<span class="string">&#x27;总成绩前20名&#x27;</span>)</span><br><span class="line">plt.scatter(min_stu[<span class="string">&#x27;初始成绩&#x27;</span>],max_stu[<span class="string">&#x27;复试成绩&#x27;</span>],color=<span class="string">&#x27;blue&#x27;</span>, label=<span class="string">&#x27;总成绩后20名&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/下载 (17).png" style="zoom:150%;" /><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/下载 (18).png" style="zoom:150%;" /><p>hhh，让我想起了向量机，有一条很明显的线将两者隔开，不过我们还是初见端倪，复旦的总成绩还是主要看重初试成绩，并且，前50的人一般分数线都在360以上哦。</p><p>看完了总成绩的前20，来看看初试成绩的前20吧。</p><p><strong>初试成绩前20和倒数20对比</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">min_stu = computer.sort_values([<span class="string">&#x27;初始成绩&#x27;</span>]).iloc[:<span class="number">20</span>]</span><br><span class="line">max_stu = computer.sort_values([<span class="string">&#x27;初始成绩&#x27;</span>],ascending=[<span class="literal">False</span>]).iloc[:<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line">plt.scatter(max_stu[<span class="string">&#x27;初始成绩&#x27;</span>],max_stu[<span class="string">&#x27;复试成绩&#x27;</span>],color=<span class="string">&#x27;green&#x27;</span>, label=<span class="string">&#x27;总成绩前20名&#x27;</span>)</span><br><span class="line">plt.scatter(min_stu[<span class="string">&#x27;初始成绩&#x27;</span>],max_stu[<span class="string">&#x27;复试成绩&#x27;</span>],color=<span class="string">&#x27;blue&#x27;</span>, label=<span class="string">&#x27;总成绩后20名&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;初始成绩&quot;</span>,&#123;<span class="string">&quot;size&quot;</span>:<span class="number">15</span>&#125;)</span><br><span class="line">plt.ylabel(<span class="string">&quot;复试成绩&quot;</span>,&#123;<span class="string">&quot;size&quot;</span>:<span class="number">15</span>&#125;)</span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/下载 (14).png" style="zoom:150%;" /><p>emmmmm，从图中并看不出复试和初试成绩的关系。。。成绩高的也是复试很低，成绩低的也有复试很高的，而且每个复试分数段的人数都差不多？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次数据分析，数据并不多，相关量也还好，主要是了解一下复旦考研的基本情况。说实话，我有点酸额，感觉这个分数也太香了吧。50%的人复试都在360以下。。。感觉比北京那边竞争小了好多好多。希望今年复旦能对我好一点。</p><p>另外，<a href="https://github.com/Mryanhehe/fudan">附上源码和数据</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;复旦大学计算机拟录取名单分析&quot;&gt;&lt;a href=&quot;#复旦大学计算机拟录取名单分析&quot; class=&quot;headerlink&quot; title=&quot;复旦大学计算机拟录取名单分析&quot;&gt;&lt;/a&gt;复旦大学计算机拟录取名单分析&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;复旦大学是考研的目标院校，最</summary>
      
    
    
    
    <category term="数据分析" scheme="https://www.mryan.cool/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
    <category term="数据分析" scheme="https://www.mryan.cool/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    <category term="复旦大学" scheme="https://www.mryan.cool/tags/%E5%A4%8D%E6%97%A6%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>数据结构练习十二</title>
    <link href="https://www.mryan.cool/2020/07/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0%E5%8D%81%E4%BA%8C/"/>
    <id>https://www.mryan.cool/2020/07/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0%E5%8D%81%E4%BA%8C/</id>
    <published>2020-07-15T06:06:17.000Z</published>
    <updated>2020-07-16T14:44:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><ol><li>建立图的邻接矩阵和邻接表的存储。并写出深度和广度优先搜索序列<ul><li>有向图</li><li>无向图</li></ul></li><li>判断给定的图G是否是连通图。若连通，则输出该生成树。若不连通，则输出其所有的连通子图（生成森林）</li><li>无向图G（不带权值）采用邻接表表示，试设计一个算法，求图G中从顶点u到顶点v的最短路径</li><li>无向图G（不带权值）采用邻接表表示，试设计一个算法，输出从顶点Vi到顶点Vj的所有简单路径</li><li>图G采用邻接表表示，试设计一个算法，求无向连通图G中距离顶点v最远的一个顶点。</li></ol><h2 id="算法设计思想"><a href="#算法设计思想" class="headerlink" title="算法设计思想"></a>算法设计思想</h2><ol><li><p>该题比较简单，就不说了</p></li><li><p> 对深度遍历和广度遍历的应用。如果可以一次深度遍历或者广度遍历完，就是联通图，否则就不是</p></li><li><p>利用广度优先遍历算法，从u出发进行广度遍历，类似于从顶点u出发一层一层地向外扩展，当第一次找到顶点v时队列中便包含了从顶点u到顶点v最近的路径，如图所示，再利用队列输出最路径（逆路径），所以设计成非循环队列</p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/20150718104613590"></p></li><li><p>利用深度遍历和栈，每次向下遍历就将该节点放入栈中。</p></li><li><p>利用Dijkstra，算出该点到其余点的距离，在从中取出一条距离最长的点。</p></li></ol><h3 id="作业一"><a href="#作业一" class="headerlink" title="作业一"></a>作业一</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵深度遍历</span></span><br><span class="line"><span class="keyword">bool</span> visited[MAXVEX] ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(MGgraph *G,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    visited[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,G-&gt;vex[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j&lt;G-&gt;numV ;j++)</span><br><span class="line">        <span class="keyword">if</span>(G-&gt;arc[i][j] &gt;= <span class="number">1</span> &amp;&amp; G-&gt;arc[i][j] &lt;= INFINITY &amp;&amp; !visited[j])</span><br><span class="line">            DFS(G,j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsMGtravrse</span><span class="params">(MGgraph *G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>  ; i &lt; G-&gt;numV ; i++)</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G-&gt;numV ; i++)</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            DFS(G,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接矩阵广度遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(MGgraph *G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q[MAXVEX];</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; G-&gt;numV ; i ++)</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G-&gt;numV ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;data is %d\t&quot;</span>,G-&gt;vex[i]);</span><br><span class="line">            q[rear ++] = i;</span><br><span class="line">            <span class="keyword">while</span>( rear - front != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> k = q[front++];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; G-&gt;numV ;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(G-&gt;arc[k][j] &gt;= <span class="number">1</span> &amp;&amp; G-&gt;arc[k][j] &lt; INFINITY &amp;&amp; !visited[j])&#123;</span><br><span class="line">                        visited[j] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;data is %d\t&quot;</span>,G-&gt;vex[j]);</span><br><span class="line">                        q[rear++] = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 邻接表深度遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ALGdfs</span><span class="params">(GraphAdjList* G ,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    EdgeNode* e;</span><br><span class="line">    visited[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data is %d\t&quot;</span>,G-&gt;adjlist[i].data);</span><br><span class="line">    e = G-&gt;adjlist[i].firstedge;</span><br><span class="line">    <span class="keyword">while</span>(e)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[e-&gt;adjvex])</span><br><span class="line">            ALGdfs(G , e-&gt;adjvex);</span><br><span class="line">        e = e-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ALGdfsTraverse</span><span class="params">(GraphAdjList* G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G-&gt;numV ; i++)</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G-&gt;numV ; i++)</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])</span><br><span class="line">                ALGdfs(G,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//邻接表广度优先</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ALGbfs</span><span class="params">(GraphAdjList* G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G-&gt;numV ; i++)</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> q[MAXVEX];</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; G-&gt;numV ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;data is %d\t&quot;</span>,G-&gt;adjlist[i].data);</span><br><span class="line">            q[rear++] = G-&gt;adjlist[i].data;</span><br><span class="line">            <span class="keyword">while</span>( rear - front != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> j =  q[front++];</span><br><span class="line">                EdgeNode* e = G-&gt;adjlist[j].firstedge;</span><br><span class="line">                <span class="keyword">while</span>(e)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!visited[e-&gt;adjvex])&#123;</span><br><span class="line">                        visited[e-&gt;adjvex] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;data is %d\t&quot;</span>,G-&gt;adjlist[e-&gt;adjvex].data);</span><br><span class="line">                        q[rear++] = e-&gt;adjvex;</span><br><span class="line">                    &#125;</span><br><span class="line">                    e = e-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业二"><a href="#作业二" class="headerlink" title="作业二"></a>作业二</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MGjudge</span><span class="params">(MGgraph *G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = G-&gt;numV;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; length ; i++)</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    DFS(G,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; length ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            DFS(G,i);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">adjlistJudge</span><span class="params">(GraphAdjList *G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = G-&gt;numV;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; length ; i++)</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    ALGbfs(G);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; length ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业三"><a href="#作业三" class="headerlink" title="作业三"></a>作业三</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找出A到B的最短路径</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findShortestPathFromAtoB</span><span class="params">(GraphAdjList *G , <span class="keyword">int</span> A , <span class="keyword">int</span> B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q[MAXVEX];</span><br><span class="line">    <span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span> , count = <span class="number">1</span>;</span><br><span class="line">    q[rear ++] = A;</span><br><span class="line">    <span class="keyword">while</span>(rear - front != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = q[front++];</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">            len++;</span><br><span class="line">        <span class="keyword">if</span>(temp = B)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        EdgeNode* e = (EdgeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));</span><br><span class="line">        e = G-&gt;adjlist[A].firstedge;</span><br><span class="line">        <span class="keyword">while</span>(e)&#123;</span><br><span class="line">            q[rear++] = e-&gt;adjvex;</span><br><span class="line">            e = e-&gt;next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业四"><a href="#作业四" class="headerlink" title="作业四"></a>作业四</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsFindAllPathFromAToB</span><span class="params">(GraphAdjList* G,<span class="keyword">int</span> A,<span class="keyword">int</span> B,<span class="keyword">int</span>* <span class="built_in">stack</span>,<span class="keyword">int</span> stack_length)</span></span>&#123;</span><br><span class="line">    EdgeNode* e = (EdgeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));</span><br><span class="line">    e = G-&gt;adjlist[A].firstedge;</span><br><span class="line">    <span class="keyword">while</span>(e)&#123;</span><br><span class="line">        <span class="built_in">stack</span>[stack_length++] = e-&gt;adjvex;</span><br><span class="line">        <span class="keyword">if</span>(e-&gt;adjvex == B)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; stack_length ; i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,<span class="built_in">stack</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfsFindAllPathFromAToB(G,e-&gt;adjvex,B,<span class="built_in">stack</span>,stack_length);</span><br><span class="line">        e-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findAllPathFromAToB</span><span class="params">(GraphAdjList* G ,<span class="keyword">int</span> A , <span class="keyword">int</span> B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[MAXVEX];</span><br><span class="line">    <span class="keyword">int</span> stack_length = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>[stack_length++] = A;</span><br><span class="line">    dfsFindAllPathFromAToB(G , A,B,<span class="built_in">stack</span>,stack_length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业五"><a href="#作业五" class="headerlink" title="作业五"></a>作业五</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">Dijkstra</span><span class="params">(GraphAdjList* G , <span class="keyword">int</span> A)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span>* current = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">bool</span>) * G-&gt;numV);</span><br><span class="line">    <span class="keyword">int</span>* distance = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * G-&gt;numV);</span><br><span class="line">    <span class="keyword">int</span> length = G-&gt;numV;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; length ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == A)&#123;</span><br><span class="line">            current[i] = <span class="literal">true</span>;</span><br><span class="line">            distance[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            current[i] = <span class="literal">false</span>;</span><br><span class="line">            distance[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    EdgeNode* e = (EdgeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));</span><br><span class="line">    e = G-&gt;adjlist[A].firstedge;</span><br><span class="line">    distance[A] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(e)&#123;</span><br><span class="line">        distance[e-&gt;adjvex] = e-&gt;weight;</span><br><span class="line">        e = e-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; length ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(distance[i] == <span class="number">-1</span>)</span><br><span class="line">            distance[i] = INFINITY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; length ; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min ,index;</span><br><span class="line">        min = INFINITY ,index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找到最近的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; length ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(distance[j] &lt; min &amp;&amp; !current[j])&#123;</span><br><span class="line">                min = distance[j];</span><br><span class="line">                index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将该点选中current</span></span><br><span class="line">        current[index] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 修正distance</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span> ; j &lt; length ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(current[j])&#123;</span><br><span class="line">                e = G-&gt;adjlist[j].firstedge;</span><br><span class="line">                <span class="keyword">while</span>(e)&#123;</span><br><span class="line">                    <span class="keyword">int</span> curLength = e-&gt;weight;</span><br><span class="line">                    <span class="keyword">int</span> point = e-&gt;adjvex;</span><br><span class="line">                    <span class="keyword">if</span>(distance[j] + curLength &lt; distance[point])</span><br><span class="line">                        distance[point] = distance[j] + curLength;</span><br><span class="line">                    e = e-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;建立图的邻接矩阵和邻接表的存储。并写出深度和广度优先搜索序列&lt;ul&gt;
&lt;li&gt;有向图&lt;/li&gt;
&lt;li&gt;无向图&lt;/li&gt;
&lt;/u</summary>
      
    
    
    
    <category term="数据结构练习" scheme="https://www.mryan.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="数据结构" scheme="https://www.mryan.cool/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C语言" scheme="https://www.mryan.cool/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="算法" scheme="https://www.mryan.cool/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>机器学习实战-KNN</title>
    <link href="https://www.mryan.cool/2020/07/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-KNN/"/>
    <id>https://www.mryan.cool/2020/07/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-KNN/</id>
    <published>2020-07-10T03:03:17.000Z</published>
    <updated>2020-07-10T03:10:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="K-近邻算法"><a href="#K-近邻算法" class="headerlink" title="K-近邻算法"></a>K-近邻算法</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>存在一个样本数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一数据与所属分类的对应关系。输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）的分类标签。</p><p>一般来说，我们 只选择样本数据集中前k个最相似的数据，这就是k-近邻算法中k的出处，通常k是不大于20的整数。 最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类。</p><h2 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h2><ol><li>收集数据</li><li>准备数据</li><li>分析数据</li><li>训练数据</li><li>测试数据</li><li>使用算法</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;K-近邻算法&quot;&gt;&lt;a href=&quot;#K-近邻算法&quot; class=&quot;headerlink&quot; title=&quot;K-近邻算法&quot;&gt;&lt;/a&gt;K-近邻算法&lt;/h1&gt;&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构练习十一</title>
    <link href="https://www.mryan.cool/2020/07/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0%E5%8D%81%E4%B8%80/"/>
    <id>https://www.mryan.cool/2020/07/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0%E5%8D%81%E4%B8%80/</id>
    <published>2020-07-07T12:59:57.000Z</published>
    <updated>2020-07-07T14:51:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol><li>建立树的孩子兄弟表示法存储</li><li>在树的孩子兄弟表示法下，求取求取树T的高度</li><li>树采用孩子兄弟表示法存储。<br><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200707214921.png"><br>编写算法，将树中所有结点层次值置入每个结点的level域,并要求由根开始逐层输出树中的各条边，边的输出格式为（ki,kj）</li><li>已知树采用孩子兄弟表示法表示试编写算法按如下的凹入方式打印树</li></ol><h2 id="算法设计思想"><a href="#算法设计思想" class="headerlink" title="算法设计思想"></a>算法设计思想</h2><ol><li><p><strong>孩子兄弟表示法：</strong>任意一棵树，它的节点的第一个孩子如果存在就是唯一的，它的右兄弟存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟</p><p>给定一颗树，可以找到唯一的一颗二叉树与之对应，因此，可以用一颗二叉树来表示一颗树的结构。如图：</p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/2-1FS015503O53.png" alt="img"></p></li></ol><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/2-1FS0160020200.png" alt="img"></p><ol start="2"><li><p>既然我们可以将树转化为孩子兄弟表示法，这种方法用二叉链表的形式实现，那么我们考虑用求二叉树深度的方法来求树的深度。</p><p>区别在于，孩子兄弟表示法中每个节点的右子树是这个节点的兄弟，在原树中并不占深度，所以只需修改算法的求右子树高度的部分即可。</p></li><li><p>要输出树中各边，存在边，即两节点在树中是父子关系。</p><p>如果节点有孩子，就打印（该节点，孩子节点），然后遍历孩子结点的兄弟节点。</p><p>递归进入孩子节点，兄弟节点</p></li><li><p>首先不考虑前面的每个元素前面的空格，得到打印序列是ABEFCGD，发现这是孩子兄弟表示法的前序遍历结果，然后利用上面第二题的算法获得每个元素的层号，然后打印空格，就可以实现凹入方式打印这棵树了</p></li></ol><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><h3 id="作业一"><a href="#作业一" class="headerlink" title="作业一"></a>作业一</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createCSTree</span><span class="params">(CSTree *root )</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="comment">// printf(&quot;please input\t:&quot;);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c);</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">        *root = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *root = (CSNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CSTree));</span><br><span class="line">        (*root)-&gt;element = c;</span><br><span class="line">        (*root)-&gt;level = <span class="number">0</span>;</span><br><span class="line">        createCSTree(&amp;(*root)-&gt;firstChild);</span><br><span class="line">        createCSTree(&amp;(*root)-&gt;nextsibing);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业二"><a href="#作业二" class="headerlink" title="作业二"></a>作业二</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCSTreeHeight</span><span class="params">(CSTree *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*root)&#123;</span><br><span class="line">        <span class="keyword">int</span> child = getCSTreeHeight(&amp;(*root)-&gt;firstChild) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> sibing = getCSTreeHeight(&amp;(*root)-&gt;nextsibing);</span><br><span class="line">        <span class="keyword">return</span> child &gt; sibing ? child:sibing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业三"><a href="#作业三" class="headerlink" title="作业三"></a>作业三</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getLevel</span><span class="params">(CSTree* root , <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*root)&#123;</span><br><span class="line">        (*root)-&gt;level = level;</span><br><span class="line">        getLevel(&amp;(*root)-&gt;firstChild , level+<span class="number">1</span>);</span><br><span class="line">        getLevel(&amp;(*root)-&gt;nextsibing , level);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inputBorder</span><span class="params">(CSTree* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*root)&#123;</span><br><span class="line">        <span class="keyword">if</span>((*root)-&gt;firstChild)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c%c,\t&quot;</span>,(*root)-&gt;element,(*root)-&gt;firstChild-&gt;element);</span><br><span class="line">            CSNode* temp = (*root)-&gt;firstChild-&gt;nextsibing;</span><br><span class="line">            <span class="keyword">while</span>(temp)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c%c,\t&quot;</span>,(*root)-&gt;element,temp-&gt;element);</span><br><span class="line">                temp = temp-&gt;nextsibing;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        inputBorder(&amp;(*root)-&gt;firstChild);</span><br><span class="line">        inputBorder(&amp;(*root)-&gt;nextsibing);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业四"><a href="#作业四" class="headerlink" title="作业四"></a>作业四</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(CSTree root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; root-&gt;level ; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,root-&gt;element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inputGrid</span><span class="params">(CSTree root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)&#123;</span><br><span class="line">        visit(root);</span><br><span class="line">        inputGrid(root-&gt;firstChild);</span><br><span class="line">        inputGrid(root-&gt;nextsibing);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;建立树的孩子兄弟表示法存储&lt;/li&gt;
&lt;li&gt;在树的孩子兄弟表示法下，求取求取树T的高度&lt;/li&gt;
&lt;li&gt;树采用孩子兄弟表示法</summary>
      
    
    
    
    <category term="数据结构练习" scheme="https://www.mryan.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="数据结构" scheme="https://www.mryan.cool/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C语言" scheme="https://www.mryan.cool/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="算法" scheme="https://www.mryan.cool/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构第八章——查找</title>
    <link href="https://www.mryan.cool/2020/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%85%AB%E7%AB%A0%E2%80%94%E2%80%94%E6%9F%A5%E6%89%BE/"/>
    <id>https://www.mryan.cool/2020/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%85%AB%E7%AB%A0%E2%80%94%E2%80%94%E6%9F%A5%E6%89%BE/</id>
    <published>2020-07-03T01:01:55.000Z</published>
    <updated>2020-07-03T01:27:26.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="顺序查找法"><a href="#顺序查找法" class="headerlink" title="顺序查找法"></a>顺序查找法</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;查找&quot;&gt;&lt;a href=&quot;#查找&quot; class=&quot;headerlink&quot; title=&quot;查找&quot;&gt;&lt;/a&gt;查找&lt;/h1&gt;&lt;h2 id=&quot;顺序查找法&quot;&gt;&lt;a href=&quot;#顺序查找法&quot; class=&quot;headerlink&quot; title=&quot;顺序查找法&quot;&gt;&lt;/a&gt;顺序查找</summary>
      
    
    
    
    <category term="数据结构" scheme="https://www.mryan.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构笔记" scheme="https://www.mryan.cool/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>操作系统——文件系统</title>
    <link href="https://www.mryan.cool/2020/07/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://www.mryan.cool/2020/07/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-07-01T06:01:46.000Z</published>
    <updated>2020-07-01T09:16:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200701141015.png"></p><h2 id="文件系统的功能"><a href="#文件系统的功能" class="headerlink" title="文件系统的功能"></a>文件系统的功能</h2><ol><li>文件的按名存取</li><li>文件目录建立和维护</li><li>实现逻辑文件到物理文件转换</li><li>文件存储空间的分配和管理</li><li>提供合适的文件存取方法</li><li>实现文件的共享、保护和保密</li><li>提供一组可供用户使用的文件操作</li></ol><h2 id="文件信息的分层结构"><a href="#文件信息的分层结构" class="headerlink" title="文件信息的分层结构"></a>文件信息的分层结构</h2><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>实现文件的逻辑结构，为用户提供系统调用等工作</p><h3 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h3><p>负责查找文件描述符</p><h3 id="外存映射管理"><a href="#外存映射管理" class="headerlink" title="外存映射管理"></a>外存映射管理</h3><p>将文件的逻辑地址转换成磁盘的物理地址。</p><h2 id="文件存取"><a href="#文件存取" class="headerlink" title="文件存取"></a>文件存取</h2><ol><li>顺序存取</li><li>直接（随机）存取</li><li>索引存取</li><li>按值存取</li></ol><h2 id="文件目录和文件检索"><a href="#文件目录和文件检索" class="headerlink" title="文件目录和文件检索"></a>文件目录和文件检索</h2><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p>存放管理文件所需信息的数据结构</p><p>一个文件的文件目录即其目录项，又称为文件控制块（FCB）</p><ol><li>文件和文件控制块一一对应</li><li>FCB通常包括：<strong>文件名</strong>，用户名，类型，文件结构，建立日期，存取权限，<strong>物理地址</strong>等</li></ol><h3 id="目录文件"><a href="#目录文件" class="headerlink" title="目录文件"></a>目录文件</h3><p>把FCB集中起来，组成文件，保存在外存</p><h4 id="单机目录"><a href="#单机目录" class="headerlink" title="单机目录"></a>单机目录</h4><p>整个系统只有一张目录表，所有文件均登录在该表</p><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ol><li>不允许重名</li><li>查找速度慢</li></ol><h4 id="二级目录"><a href="#二级目录" class="headerlink" title="二级目录"></a>二级目录</h4><p>系统设置唯一一个主文件目录MFD，每个用户设立一个用户文件目录UFD，UFD又该用户所有文件的FCB构成。</p><p><strong>优点</strong>：</p><ol><li>提高了查找速度</li><li>解决了重名问题</li></ol><h4 id="多级目录"><a href="#多级目录" class="headerlink" title="多级目录"></a>多级目录</h4><p>树形目录结构</p><h2 id="UNIX-Linux目录项"><a href="#UNIX-Linux目录项" class="headerlink" title="UNIX/Linux目录项"></a>UNIX/Linux目录项</h2><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200701144409.png"></p><p><strong>将FCB的分为文件名和其他</strong></p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200701144637.png"></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li><p><strong>将FCB除文件名的其他信息全部存放在磁盘上，大大减少了占用内存的空间。</strong></p></li><li><p>因为按文件名检索文件，只用到了文件名。当找到了文件才需要其他描述信息。所以在把存放在该目录文件的盘块从外存调入内存比较时，应使一个盘块重包含尽量多的文件名，以<strong>减少访问磁盘次数，加快文件检索速度。</strong></p><ul><li>大部分信息都是检索不需要用到的</li></ul></li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200701145142.png"></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="文件结构与文件存储"><a href="#文件结构与文件存储" class="headerlink" title="文件结构与文件存储"></a>文件结构与文件存储</h2><h3 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3><ol><li>记录式文件：由若干记录所构成</li><li>流式文件：若干字符序列构成</li></ol><h3 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h3><ol><li>顺序文件：顺序放在物理快</li><li>链接文件：通过指针连接成链表</li><li>索引文件：为每个文件建立一个索引表</li></ol><h2 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h2><h3 id="空闲盘块管理"><a href="#空闲盘块管理" class="headerlink" title="空闲盘块管理"></a>空闲盘块管理</h3><p>常用空闲空间管理技术</p><ol><li>位示图</li><li>空闲块列表</li><li>空闲区链表</li><li>空闲块索引</li></ol><h2 id="文件共享和文件保护"><a href="#文件共享和文件保护" class="headerlink" title="文件共享和文件保护"></a>文件共享和文件保护</h2><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><h3 id="同时访问"><a href="#同时访问" class="headerlink" title="同时访问"></a>同时访问</h3><ol><li>加锁</li><li>互斥和死锁问题</li></ol><h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><h4 id="基于目录指针实现文件共享"><a href="#基于目录指针实现文件共享" class="headerlink" title="基于目录指针实现文件共享"></a>基于目录指针实现文件共享</h4><h4 id="利用索引节点（i结点）"><a href="#利用索引节点（i结点）" class="headerlink" title="利用索引节点（i结点）"></a>利用索引节点（i结点）</h4><h4 id="利用符号链"><a href="#利用符号链" class="headerlink" title="利用符号链"></a>利用符号链</h4><h3 id="UNIX文件保护"><a href="#UNIX文件保护" class="headerlink" title="UNIX文件保护"></a>UNIX文件保护</h3><p>UNIX/Linux把用户分成三类</p><ol><li>文件主</li><li>同组用户</li><li>其他用户</li></ol><p>三种存取权限，rwx</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件系统&quot;&gt;&lt;a href=&quot;#文件系统&quot; class=&quot;headerlink&quot; title=&quot;文件系统&quot;&gt;&lt;/a&gt;文件系统&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud</summary>
      
    
    
    
    <category term="操作系统笔记" scheme="https://www.mryan.cool/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="操作系统" scheme="https://www.mryan.cool/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="笔记" scheme="https://www.mryan.cool/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构第七章</title>
    <link href="https://www.mryan.cool/2020/06/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
    <id>https://www.mryan.cool/2020/06/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%B8%83%E7%AB%A0/</id>
    <published>2020-06-27T23:58:23.000Z</published>
    <updated>2020-06-28T03:55:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="图的定义和基本术语"><a href="#图的定义和基本术语" class="headerlink" title="图的定义和基本术语"></a>图的定义和基本术语</h2><p>图：一张网状数据结构</p><ol><li><p>有向图：图中边有方向</p></li><li><p>无向图：图中边无方向</p></li><li><p>完全图：一个顶点和其余的点都相联</p><ol><li>有向完全图</li><li>无向完全图</li></ol></li><li><p>子图：A是B图的一部分</p></li><li><p>连通图：无向图中，对于两个点都可以连通</p><ol><li>连通分量：无向图中的极大连通子图</li><li>强连通图：有向图中，对于两个点都可以连通</li><li>强连通分量：有向图的极大连通子图</li></ol></li></ol><p>赋权图（网）：带权的图，图的边或弧上相关的数成为<strong>权</strong></p><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><p>需存储两部分信息：</p><ol><li>顶点</li><li>顶点间关系</li></ol><p>方法：</p><ol><li>邻接矩阵</li><li>邻接表</li><li>十字链表</li><li>邻接多重表</li></ol><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>定义：用两个数组来表示图</p><ol><li><p>一维数组存放定点信息</p></li><li><p>二维数组存放顶点关联信息</p></li></ol><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200628081925.png"></p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200628082015.png"></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><h5 id="存储空间"><a href="#存储空间" class="headerlink" title="存储空间"></a>存储空间</h5><ol><li><p>无向图：邻接矩阵是对称矩阵，可使用采用存储法（下三角）,其存储空间为$\frac{n}{2*(n-1)}$</p></li><li><p>有向图：不一定是堆成矩阵，存储空间为$n^2$</p></li></ol><h5 id="度："><a href="#度：" class="headerlink" title="度："></a>度：</h5><pre><code>1. 无向图：第i行元素之和就是i个顶点的度 2. 有向图：第i行元素之和就是i个顶点的出度，第i列元素之和就是i个顶尖的入度</code></pre><h5 id="便于实现基本操作"><a href="#便于实现基本操作" class="headerlink" title="便于实现基本操作"></a>便于实现基本操作</h5><h3 id="邻接表表示法"><a href="#邻接表表示法" class="headerlink" title="邻接表表示法"></a>邻接表表示法</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>只存储图中有关联的边的信息</p><p>​    1. 图中n个顶点均建立有关联的边链表</p><h4 id="结构构成"><a href="#结构构成" class="headerlink" title="结构构成"></a>结构构成</h4><ol><li>表头结点表</li><li>边表</li></ol><h4 id="度"><a href="#度" class="headerlink" title="度"></a>度</h4><ol><li>无向图：顶点$v_i$的度恰好是他链表的个数</li><li>有向图：i个边链表上顶点的个数是初读，入度必须遍历整个邻接表</li></ol><h6 id="可构建一个逆邻接表"><a href="#可构建一个逆邻接表" class="headerlink" title="可构建一个逆邻接表"></a>可构建一个逆邻接表</h6><p>计算出度用正向，计算入度用逆向</p><h3 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h3><p>将邻接表和逆邻接表结合起来。</p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200628083638.png"></p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>方便求出度</p><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>从图中某个顶点出发，按某种方法对图中的所有顶点访问且访问一次</p><h3 id="深度优先DFS"><a href="#深度优先DFS" class="headerlink" title="深度优先DFS"></a>深度优先DFS</h3><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200628091612.png"></p><h3 id="广度优先DFS"><a href="#广度优先DFS" class="headerlink" title="广度优先DFS"></a>广度优先DFS</h3><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200628094033.png"></p><h2 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h2><h4 id="图的连通性问题"><a href="#图的连通性问题" class="headerlink" title="图的连通性问题"></a>图的连通性问题</h4><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><h5 id="AOV网"><a href="#AOV网" class="headerlink" title="AOV网"></a>AOV网</h5><p>拓扑序列：有一条$v_i$到$v_j$的路径，则在拓扑序列中$v_i$必排在$v_j$之前</p><h6 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h6><ol><li>先行关系具有可传递性</li><li>拓扑序列不唯一</li></ol><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><h5 id="集于邻接矩阵"><a href="#集于邻接矩阵" class="headerlink" title="集于邻接矩阵"></a>集于邻接矩阵</h5><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200628105935.png"></p><h5 id="集于邻接表"><a href="#集于邻接表" class="headerlink" title="集于邻接表"></a>集于邻接表</h5><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200628110154.png"></p><h4 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h4><h5 id="某一顶点到其他顶点的最点距离"><a href="#某一顶点到其他顶点的最点距离" class="headerlink" title="某一顶点到其他顶点的最点距离"></a>某一顶点到其他顶点的最点距离</h5><h6 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h6><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200628112413.png"></p><h5 id="任意一对顶点的最短路径"><a href="#任意一对顶点的最短路径" class="headerlink" title="任意一对顶点的最短路径"></a>任意一对顶点的最短路径</h5><h6 id="弗洛伊德算法"><a href="#弗洛伊德算法" class="headerlink" title="弗洛伊德算法"></a>弗洛伊德算法</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图&quot;&gt;&lt;a href=&quot;#图&quot; class=&quot;headerlink&quot; title=&quot;图&quot;&gt;&lt;/a&gt;图&lt;/h1&gt;&lt;h2 id=&quot;图的定义和基本术语&quot;&gt;&lt;a href=&quot;#图的定义和基本术语&quot; class=&quot;headerlink&quot; title=&quot;图的定义和基本术语&quot;&gt;</summary>
      
    
    
    
    <category term="数据结构" scheme="https://www.mryan.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构笔记" scheme="https://www.mryan.cool/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>操作系统笔记--设备管理</title>
    <link href="https://www.mryan.cool/2020/06/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/"/>
    <id>https://www.mryan.cool/2020/06/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/</id>
    <published>2020-06-24T06:01:21.000Z</published>
    <updated>2020-06-24T07:32:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h2><h4 id="I-O管理和磁盘调度"><a href="#I-O管理和磁盘调度" class="headerlink" title="I/O管理和磁盘调度"></a>I/O管理和磁盘调度</h4><ol><li>I/O设备管理概述</li><li>缓冲区技术</li><li>磁盘调度</li><li>RAID</li></ol><h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h3><h4 id="I-O设备类别"><a href="#I-O设备类别" class="headerlink" title="I/O设备类别"></a>I/O设备类别</h4><pre><code>1. 人可读 2. 机器可读 3. 通信</code></pre><h4 id="I-O设备差异"><a href="#I-O设备差异" class="headerlink" title="I/O设备差异"></a>I/O设备差异</h4><ol><li>数据速率</li><li>应用</li><li>控制的复杂性</li><li>传送单位</li><li>数据表示</li><li>错误条件</li></ol><h3 id="I-O系统的工作方式"><a href="#I-O系统的工作方式" class="headerlink" title="I/O系统的工作方式"></a>I/O系统的工作方式</h3><h4 id="I-O设备控制的四种技术"><a href="#I-O设备控制的四种技术" class="headerlink" title="I/O设备控制的四种技术"></a>I/O设备控制的四种技术</h4><ol><li>程序控制I/O</li><li>终端驱动I/O</li><li>直接存储器访问(DMA)</li><li>通道控制(I/O处理机)</li></ol><h3 id="I-O设备管理设计目标"><a href="#I-O设备管理设计目标" class="headerlink" title="I/O设备管理设计目标"></a>I/O设备管理设计目标</h3><h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><ol><li>多道程序设计</li><li>交换技术</li></ol><h4 id="通用性"><a href="#通用性" class="headerlink" title="通用性"></a>通用性</h4><ol><li>处理器看到I/O设备的方式</li><li>操作系统管理I/O设备和I/O操作的方式</li></ol><h3 id="缓冲技术–I-O缓冲"><a href="#缓冲技术–I-O缓冲" class="headerlink" title="缓冲技术–I/O缓冲"></a>缓冲技术–I/O缓冲</h3><h4 id="引入缓冲的目的"><a href="#引入缓冲的目的" class="headerlink" title="引入缓冲的目的"></a>引入缓冲的目的</h4><ol><li>改善CPU与外围设备之间速度不配的矛盾</li><li>提高CPU和I/O设备的并行性</li></ol><h4 id="缓冲的作用"><a href="#缓冲的作用" class="headerlink" title="缓冲的作用"></a>缓冲的作用</h4><ol><li>在多道程序设计环境中，当存在多种I/O活动和多种进程活动时，缓冲是提高操作系统效率和单个进程性能的一种方法</li></ol><h5 id="磁盘高速缓冲"><a href="#磁盘高速缓冲" class="headerlink" title="磁盘高速缓冲"></a>磁盘高速缓冲</h5><p><strong>磁盘高速缓冲</strong>是==内存中==为磁盘扇区设置的一个缓冲区，包含磁盘中某些扇区的副本。</p><p>进程请求访问某一特定扇区，首先检查磁盘缓冲区</p><ul><li>如果在，通过该高速缓冲来满足</li><li>不在，从扇区读到磁盘高速缓冲区</li></ul><h4 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h4><ol><li>FIFO</li><li>SSTF</li><li>SCAN</li><li>C-SCAN</li></ol><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200624145011.png"></p><h3 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h3><p>独立磁盘冗余阵列</p><p>包括7个级别，从0到6，不同级别表明不同的设计体系结构，有三个共同特性</p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200624150214.png"></p><h4 id="RADI的优势"><a href="#RADI的优势" class="headerlink" title="RADI的优势"></a>RADI的优势</h4><ol><li>改善性能–并行工作</li><li>提高可靠性–通过冗余实现容错</li></ol><p>RAID0</p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200624150710.png"></p><p>没有冗余信息</p><h4 id="RAID-1"><a href="#RAID-1" class="headerlink" title="RAID 1"></a>RAID 1</h4><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200624150916.png"></p><h4 id="RAID-2"><a href="#RAID-2" class="headerlink" title="RAID 2"></a>RAID 2</h4><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200624151014.png"></p><p>可以恢复错误</p><h4 id="RAID-3"><a href="#RAID-3" class="headerlink" title="RAID 3"></a>RAID 3</h4><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200624151115.png"></p><h4 id="RAID-4"><a href="#RAID-4" class="headerlink" title="RAID 4"></a>RAID 4</h4><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200624151131.png"></p><p>如果校验的盘出故障，就无法检验</p><h4 id="RAID-5"><a href="#RAID-5" class="headerlink" title="RAID 5"></a>RAID 5</h4><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200624151206.png"></p><p>将校验放在每个盘里面，如果校验码出错也会无法校验</p><h4 id="RAID-6"><a href="#RAID-6" class="headerlink" title="RAID 6"></a>RAID 6</h4><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200624151241.png"></p><p>对RAID5的改进，对校验码进行校验</p><h3 id="设备独立性和虚拟设备"><a href="#设备独立性和虚拟设备" class="headerlink" title="设备独立性和虚拟设备"></a>设备独立性和虚拟设备</h3><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200624151408.png"></p><h3 id="虚拟设备-SPOOLING系统"><a href="#虚拟设备-SPOOLING系统" class="headerlink" title="虚拟设备-SPOOLING系统"></a>虚拟设备-SPOOLING系统</h3><ol><li>静态分配方式不利于 提高系统效率</li><li>采用脱机外围设备操作</li><li>联机同时外围设备操作（又称假脱机操作）-SPOOLING系统</li><li>利用磁盘缓冲区模拟实现慢速I/P设备</li></ol><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200624152432.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;设备管理&quot;&gt;&lt;a href=&quot;#设备管理&quot; class=&quot;headerlink&quot; title=&quot;设备管理&quot;&gt;&lt;/a&gt;设备管理&lt;/h2&gt;&lt;h4 id=&quot;I-O管理和磁盘调度&quot;&gt;&lt;a href=&quot;#I-O管理和磁盘调度&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="操作系统笔记" scheme="https://www.mryan.cool/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="操作系统" scheme="https://www.mryan.cool/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="笔记" scheme="https://www.mryan.cool/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构实习十</title>
    <link href="https://www.mryan.cool/2020/06/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E4%B9%A0%E5%8D%81/"/>
    <id>https://www.mryan.cool/2020/06/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E4%B9%A0%E5%8D%81/</id>
    <published>2020-06-22T00:32:33.000Z</published>
    <updated>2020-06-24T15:46:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol><li>判断二叉树是否为正则二叉树<ul><li>正则二叉树的定义：指在二叉树中不存在度为1的分支点</li></ul></li><li>判断二叉树是否为完全二叉树</li><li>判断二叉树是否为二叉排序树</li><li>判断一棵二叉排序树是否为平衡的二叉排序树</li><li>求取给定的二叉树的镜像<ul><li>输入一棵二叉树，输出它的镜像。</li></ul></li><li>输出二叉树中和为某一个值的路径</li><li>判断是否为二叉排序树的后序序列</li></ol><h2 id="算法设计思想"><a href="#算法设计思想" class="headerlink" title="算法设计思想"></a>算法设计思想</h2><ol><li><p>进行递归，如果有一个二叉树只有一个节点，就返回false</p></li><li><p>在层序遍历的过程中，找到第一个非满节点(non-full node)。满节点(full-node)指的是同时拥有左右孩子的节点。在找到第一个非满节点之后，剩下的节点不应该有孩子节点；如果有，那么该二叉树就不是完全二叉树</p></li><li><p>根据二叉排序树的性质，在进行中序遍历的时候，当前结点的值总是大于前驱结点的值，需要在遍历时保存前驱结点的值，这样有利于进行判断，基于这样的思路来进行解题。</p></li><li><p>根据定义，平衡二叉树是左右子树平衡因子相差不超过2的树。我们可以利用后序，从底向上判断是否是二叉平衡树</p></li><li><p>递归进入每个节点，交换他的左子树和右子树。</p></li><li><p>对于路径，我们第一个想到的就是栈。我们可以根据树的前序遍历，往栈添加，如果到了节点，不是我们要的路径，就进行退栈。这样，栈里面就是我们要的路径。</p></li><li><p>后序的序列是LRD，根据排序树的规则，左子树小于根节点，右子树大于根节点。采用如下方法</p><ol><li>数组的最后一个节点 <strong>i</strong> 为根节点，将数组从头遍历，找到第一个大于 <strong>i</strong> 结点的结点，这个结点就是将二叉树分为左子树和右子树的分界点</li><li>分界点左边的数字为左孩子结点，左孩子结点都小于根节点，分界点右边的数字都是右孩子结点，右孩子节点都大于根节点</li><li>递归进入分界点左右两点的数组，判断左右两边的数组是不是排序二叉树的后序。</li></ol><p>终止条件</p><ol><li>对于右孩子：数组的start &gt;= end</li><li>对于左孩子，是数组的个数是否 &lt;= 2，如果等于1 则说明是后序，如果是两个节点，根据有一个结点是根节点的原则，判断第一个结点是不是大于第二个节点，如果大于返回True，否则返回false </li></ol></li></ol><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><h3 id="作业一"><a href="#作业一" class="headerlink" title="作业一"></a>作业一</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> regularTreeFlag = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ifRegularTree</span><span class="params">(biTree* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*root &amp;&amp; regularTreeFlag)&#123;</span><br><span class="line">        <span class="keyword">if</span>( (((*root)-&gt;Lchild != <span class="literal">NULL</span>) &amp;&amp; ((*root)-&gt;Rchild == <span class="literal">NULL</span>)) || (((*root)-&gt;Lchild != <span class="literal">NULL</span>) &amp;&amp; ((*root)-&gt;Rchild ==<span class="literal">NULL</span>) ))</span><br><span class="line">            regularTreeFlag = <span class="literal">false</span>;</span><br><span class="line">        ifRegularTree(&amp;(*root)-&gt;Lchild);</span><br><span class="line">        ifRegularTree(&amp;(*root)-&gt;Rchild);</span><br><span class="line">    <span class="comment">// return ifRegularTree(&amp;(*root)-&gt;Lchild) &amp;&amp; ifRegularTree(&amp;(*root)-&gt;Rchild);</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业二"><a href="#作业二" class="headerlink" title="作业二"></a>作业二</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ifFullBinaryTree</span><span class="params">(biTree *root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 该点不是标记点</span></span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    biNode temp;</span><br><span class="line">    <span class="built_in">queue</span> *q;</span><br><span class="line">    createQueue(&amp;q);</span><br><span class="line">    push(&amp;q , **root);</span><br><span class="line">    <span class="keyword">while</span>( !ifEmpty(&amp;q))</span><br><span class="line">        pop(&amp;q , &amp;temp);</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.Lchild || temp.Rchild)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.Lchild &amp;&amp; temp.Rchild)&#123;</span><br><span class="line">                push(&amp;q , *temp.Lchild);</span><br><span class="line">                push(&amp;q , *temp.Rchild);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(temp.Rchild)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业三"><a href="#作业三" class="headerlink" title="作业三"></a>作业三</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> sortTreeflag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> pre = <span class="number">-1000</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ifSortTree</span><span class="params">(biTree *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*root)&#123;</span><br><span class="line">        ifSortTree(&amp;(*root)-&gt;Lchild);</span><br><span class="line">        <span class="keyword">if</span>((*root)-&gt;element &gt;= pre)</span><br><span class="line">            pre = (*root)-&gt;element;</span><br><span class="line">        <span class="keyword">else</span> sortTreeflag = <span class="literal">false</span>;</span><br><span class="line">        ifSortTree(&amp;(*root)-&gt;Rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortTreeflag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业四"><a href="#作业四" class="headerlink" title="作业四"></a>作业四</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(biTree *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left_height = getHeight(&amp;(*root)-&gt;Lchild);</span><br><span class="line">    <span class="keyword">int</span> right_height = getHeight(&amp;(*root)-&gt;Rchild);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + (left_height &gt; right_height ? left_height : right_height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ifBalanceTree</span><span class="params">(biTree root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)&#123;</span><br><span class="line">        <span class="keyword">int</span> left = getHeight(&amp;root-&gt;Lchild);</span><br><span class="line">        <span class="keyword">int</span> right = getHeight(&amp;root-&gt;Rchild);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> ifBalanceTree(root-&gt;Lchild) &amp;&amp; ifBalanceTree(root-&gt;Rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业五"><a href="#作业五" class="headerlink" title="作业五"></a>作业五</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">biTree <span class="title">MirrorTree</span><span class="params">(biTree root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root &amp;&amp; root-&gt;Lchild != <span class="literal">NULL</span> &amp;&amp; root-&gt;Rchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        biTree temp = root-&gt;Lchild;</span><br><span class="line">        root-&gt;Lchild = root-&gt;Rchild;</span><br><span class="line">        root-&gt;Rchild = temp;</span><br><span class="line">        <span class="comment">// MirrorTree(&amp;(*root)-&gt;Lchild);</span></span><br><span class="line">        <span class="comment">// MirrorTree(&amp;(*root)-&gt;Rchild);</span></span><br><span class="line">        MirrorTree(root-&gt;Lchild);</span><br><span class="line">        MirrorTree(root-&gt;Rchild);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业六"><a href="#作业六" class="headerlink" title="作业六"></a>作业六</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPath</span><span class="params">(biTree* root , <span class="keyword">int</span> X , <span class="keyword">int</span> currentSum , Stack s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*root != <span class="literal">NULL</span> &amp;&amp; (*root)-&gt;element != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>( (*root)-&gt;Lchild == <span class="literal">NULL</span>  &amp;&amp;  (*root)-&gt;Rchild == <span class="literal">NULL</span> )&#123;</span><br><span class="line">            currentSum += (*root)-&gt;element - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>( currentSum == X)&#123;</span><br><span class="line">                s.v[s.length ++] = (*root)-&gt;element;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length ;i++)</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%c\t&quot;</span>,s.v[i]);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            currentSum += (*root)-&gt;element - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            s.v[s.length++] = (*root)-&gt;element;</span><br><span class="line">            getPath(&amp;(*root)-&gt;Lchild , X ,currentSum,s);</span><br><span class="line">            getPath(&amp;(*root)-&gt;Rchild, X , currentSum,s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业七"><a href="#作业七" class="headerlink" title="作业七"></a>作业七</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ifPostSequenceOfSortTree</span><span class="params">(<span class="keyword">int</span>* postArr ,<span class="keyword">int</span> start ,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(end - start + <span class="number">1</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(end - start+<span class="number">1</span> == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span>(postArr[start] &gt; postArr[end]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = start;</span><br><span class="line">    <span class="comment">// 找到左右子树的分界</span></span><br><span class="line">    <span class="keyword">while</span>( postArr[i] &lt; postArr[end])&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dividingLine = i;</span><br><span class="line">    <span class="comment">// 对左子树循环，左子树应该小于根节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>  ; j &lt; dividingLine ; j++)</span><br><span class="line">        <span class="keyword">if</span>(postArr[j] &gt; postArr[end])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 对右子树循环,右子树应该大于根节点</span></span><br><span class="line">    <span class="keyword">for</span>( ; i &lt;= end<span class="number">-1</span> ; i++)</span><br><span class="line">        <span class="keyword">if</span>(postArr[i] &lt; postArr[end])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> ifPostSequenceOfSortTree(postArr , start , dividingLine<span class="number">-1</span>) &amp;&amp; ifPostSequenceOfSortTree(postArr,dividingLine,end<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;判断二叉树是否为正则二叉树&lt;ul&gt;
&lt;li&gt;正则二叉树的定义：指在二叉树中不存在度为1的分支点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;</summary>
      
    
    
    
    <category term="数据结构练习" scheme="https://www.mryan.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="数据结构" scheme="https://www.mryan.cool/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C语言" scheme="https://www.mryan.cool/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="算法" scheme="https://www.mryan.cool/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>存储管理总结</title>
    <link href="https://www.mryan.cool/2020/06/21/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    <id>https://www.mryan.cool/2020/06/21/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</id>
    <published>2020-06-21T11:45:17.000Z</published>
    <updated>2020-06-21T12:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86.png">    </p><h2 id="各类存储方法比较"><a href="#各类存储方法比较" class="headerlink" title="各类存储方法比较"></a>各类存储方法比较</h2><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/工作簿2.png" style="zoom: 200%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86.png&quot;&gt;    &lt;/p&gt;
&lt;h2 id=&quot;各类存储方法比</summary>
      
    
    
    
    <category term="操作系统" scheme="https://www.mryan.cool/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="https://www.mryan.cool/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="存储管理" scheme="https://www.mryan.cool/tags/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    
    <category term="思维导图" scheme="https://www.mryan.cool/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>数据结构第六章</title>
    <link href="https://www.mryan.cool/2020/06/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    <id>https://www.mryan.cool/2020/06/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E5%85%AD%E7%AB%A0/</id>
    <published>2020-06-19T00:06:17.000Z</published>
    <updated>2020-06-19T04:02:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树遍历应用"><a href="#二叉树遍历应用" class="headerlink" title="二叉树遍历应用"></a>二叉树遍历应用</h3><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200619081241.png"></p><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><strong>原因</strong>：充分利用二叉链表的空链域</p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/2.png"></p><h4 id="中序线索化"><a href="#中序线索化" class="headerlink" title="中序线索化"></a>中序线索化</h4><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/3.png"></p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/4.png"></p><h4 id="在线索二叉树找前驱，后继节点"><a href="#在线索二叉树找前驱，后继节点" class="headerlink" title="在线索二叉树找前驱，后继节点"></a>在线索二叉树找前驱，后继节点</h4><h5 id="中序查找"><a href="#中序查找" class="headerlink" title="中序查找"></a>中序查找</h5><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/5.png"></p><p><strong>前驱在P的左子树最后访问的节点</strong>：即左子树的<strong>最右下端</strong></p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/6.png"></p><h3 id="树，森林，二叉树的关系"><a href="#树，森林，二叉树的关系" class="headerlink" title="树，森林，二叉树的关系"></a>树，森林，二叉树的关系</h3><h4 id="三者的相互转换"><a href="#三者的相互转换" class="headerlink" title="三者的相互转换"></a>三者的相互转换</h4><h5 id="树转换成二叉树"><a href="#树转换成二叉树" class="headerlink" title="树转换成二叉树"></a>树转换成二叉树</h5><h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/7.png"></h5><h5 id="森林转换成二叉树"><a href="#森林转换成二叉树" class="headerlink" title="森林转换成二叉树"></a>森林转换成二叉树</h5><h5 id="二叉树还原成树或森林"><a href="#二叉树还原成树或森林" class="headerlink" title="二叉树还原成树或森林"></a>二叉树还原成树或森林</h5><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/8.png"></p><p><strong>PS：树的孩子兄弟表示法和二叉树的孩子表示法的存储结构相对应</strong></p><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p>带权路径长度：从树根到某一结点的路径长度乘以该节点的权重之和，极为$WPL= \sum_{i=1}^{n}\ P_i*W_i$</p><p>霍夫曼树：二叉树的带权路径长度最小</p><p>完全二叉树的路径长度为：$\sum_{k=1}^{n}\log_2[k]$，路径长度最小</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/9.png"></p><h4 id="哈夫曼树的类型定义"><a href="#哈夫曼树的类型定义" class="headerlink" title="哈夫曼树的类型定义"></a>哈夫曼树的类型定义</h4><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/10.png"></p><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/11.png"></p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/12.png"></p><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/13.png"></p><h4 id="由哈夫曼树求编码-算法实现"><a href="#由哈夫曼树求编码-算法实现" class="headerlink" title="由哈夫曼树求编码 算法实现"></a>由哈夫曼树求编码 算法实现</h4><p><img src="https://mryanhehe-1300112970.cos.ap-chengdu.myqcloud.com/img/14.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; title=&quot;树&quot;&gt;&lt;/a&gt;树&lt;/h2&gt;&lt;h3 id=&quot;二叉树遍历应用&quot;&gt;&lt;a href=&quot;#二叉树遍历应用&quot; class=&quot;headerlink&quot; title=&quot;二叉树遍历应用&quot;&gt;&lt;/a&gt;二叉</summary>
      
    
    
    
    <category term="数据结构" scheme="https://www.mryan.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构笔记" scheme="https://www.mryan.cool/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构实习九</title>
    <link href="https://www.mryan.cool/2020/06/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E4%B9%A0%E4%B9%9D/"/>
    <id>https://www.mryan.cool/2020/06/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E4%B9%A0%E4%B9%9D/</id>
    <published>2020-06-14T09:48:38.000Z</published>
    <updated>2020-06-15T03:51:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol><li><p>建二叉树二叉链表存储</p><ul><li>根据先序，中序建立二叉树</li><li>根据后续，中序建立二叉树</li></ul></li><li><p>求二叉树中值为x的节点所在的层号</p></li><li><p>求二叉树的宽度</p></li><li><p>二叉树bt采用二叉链表存储，设计算法实现采用括号表示法输出该二叉树</p><p><img src="https://s1.ax1x.com/2020/06/14/NSTfIJ.png"></p></li><li><p>求二叉树的路径长度</p><ul><li>二叉树的路径长度即：二叉树中所有结点的路径长度之和。</li></ul></li></ol><h2 id="算法设计思想"><a href="#算法设计思想" class="headerlink" title="算法设计思想"></a>算法设计思想</h2><ol><li><p>根据二叉树前序，中序的规则，先序第一个为根节点，该点在中序中，左右分别是其左孩子，右孩子。不断进行递归，</p><p>比如先序为“<em>12467835</em>”，中序为“47682135”的二叉树</p><ol><li>根节点为1，47682为左孩子，35为右孩子</li><li>对于47682，在前序中，找到第一个节点，为2，说明该二叉树的根节点为2</li><li>对于35，在前序中，找到第一个节点为3，说明该二叉树的根节点为3</li><li>然后不断递归，直到每个二叉树的节点的节点只有一个元素。</li></ol></li><li><p>根据递归，一层一层向下查找，如果在当前层找到了x，就返回当前层的层号</p></li><li><p>根据队列，设置一个len，代表每层的个数，出队列就减1，如果len=0，说明该层的元素全部出列，此时队列中的元素全部是下一层的元素，于是令len=当前队列元素。便通过len表示了每层的元素个数。同时在变化的过程中，用一个参数maxdepth来记录len的最大值，maxdepth就是我们要的最大宽度</p></li><li><p>利用递归，结合题目，我们可以看到先打印字符，如果有孩子，先打印(，在判断有无左孩子，有的话，输入字符，没有的话，输入‘，’,转到右孩子，然后打印’)’。直到遍历到底。</p></li><li><p>每个节点的路径就是他的高度减1，设置一个全局变量，对每个点进行遍历，加上他的高度便可。</p></li></ol><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><h3 id="作业一"><a href="#作业一" class="headerlink" title="作业一"></a>作业一</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据先序和后序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTreeByPreAndMid</span><span class="params">(biTree *root , elementType* pre,<span class="keyword">int</span> preStart, <span class="keyword">int</span> preEnd , elementType* mid ,<span class="keyword">int</span> midStart ,<span class="keyword">int</span> midEnd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preStart &lt;= preEnd &amp;&amp; midStart &lt;= midEnd)&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = midStart ; i &lt;= midEnd ; i++)&#123;</span><br><span class="line">            <span class="comment">// 在中序找到和前序对应的节点</span></span><br><span class="line">            <span class="keyword">if</span>(mid[i] == pre[preStart])&#123;</span><br><span class="line">                *root = (biNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(biNode));</span><br><span class="line">                (*root)-&gt;element = mid[i];</span><br><span class="line">                <span class="comment">// 左节点为in左边的数组，右节点为in右边的数组</span></span><br><span class="line">                createTreeByPreAndMid(&amp;(*root)-&gt;Lchild,pre,preStart+<span class="number">1</span>,preStart+i-midStart,mid,midStart,i<span class="number">-1</span>);</span><br><span class="line">                createTreeByPreAndMid(&amp;(*root)-&gt;Rchild,pre,preStart+i-midStart+<span class="number">1</span>,preEnd,mid,i+<span class="number">1</span>,midEnd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        *root = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据中序和后序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTreeByMidAndPost</span><span class="params">(biTree *root , elementType* post,<span class="keyword">int</span> postStart, <span class="keyword">int</span> postEnd , elementType* mid ,<span class="keyword">int</span> midStart ,<span class="keyword">int</span> midEnd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(postStart &lt;= postEnd &amp;&amp; midStart &lt;= midEnd)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = midStart ; i&lt;= midEnd ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mid[i] == post[postEnd])&#123;</span><br><span class="line">                *root = (biNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(biNode));</span><br><span class="line">                (*root)-&gt;element = mid[i];</span><br><span class="line">                createTreeByMidAndPost(&amp;(*root)-&gt;Lchild , post ,postStart,i-midStart<span class="number">-1</span>,mid,midStart,i<span class="number">-1</span>);</span><br><span class="line">                createTreeByMidAndPost(&amp;(*root)-&gt;Rchild,post,i-midStart,postEnd<span class="number">-1</span>,mid,i+<span class="number">1</span>,midEnd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        *root = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业二"><a href="#作业二" class="headerlink" title="作业二"></a>作业二</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来判断是否已经找到</span></span><br><span class="line"><span class="keyword">int</span> flag;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findLevelofX</span><span class="params">(biTree* root ,<span class="keyword">int</span> num,elementType x,<span class="keyword">int</span>* res )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*root &amp;&amp; flag == <span class="number">0</span> )&#123;</span><br><span class="line">        elementType temp = (*root)-&gt;element;</span><br><span class="line">        <span class="keyword">if</span>((*root)-&gt;element == x)&#123;</span><br><span class="line">            *res = num;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            *res = error;</span><br><span class="line">            findLevelofX(&amp;(*root)-&gt;Lchild,num+<span class="number">1</span> , x,res);</span><br><span class="line">            findLevelofX(&amp;(*root)-&gt;Rchild,num+<span class="number">1</span> , x,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业三"><a href="#作业三" class="headerlink" title="作业三"></a>作业三</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(biTree* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxlength=<span class="number">0</span>;</span><br><span class="line">    biNode temp;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">queue</span> *q;</span><br><span class="line">    createQueue(&amp;q);</span><br><span class="line">    push(&amp;q , **root);</span><br><span class="line">    len = <span class="number">1</span>;</span><br><span class="line">    maxlength = maxlength &gt; len ? maxlength : len;</span><br><span class="line">    <span class="keyword">while</span>( ifEmpty(&amp;q) == False)&#123;</span><br><span class="line">        pop(&amp;q , &amp;temp);</span><br><span class="line">        len--;</span><br><span class="line">        <span class="keyword">if</span>( temp.Lchild )</span><br><span class="line">            push(&amp;q , *(temp.Lchild));</span><br><span class="line">        <span class="keyword">if</span>( temp.Rchild )</span><br><span class="line">            push(&amp;q,*(temp.Rchild));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)&#123;</span><br><span class="line">            len = q-&gt;rear - q-&gt;front;</span><br><span class="line">            maxlength = maxlength &gt; len ? maxlength : len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxlength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业四"><a href="#作业四" class="headerlink" title="作业四"></a>作业四</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getParentheses</span><span class="params">(biTree* root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*root)&#123;</span><br><span class="line">        str[begin++] = (*root)-&gt;element;</span><br><span class="line">        <span class="keyword">if</span>((*root)-&gt;Lchild || (*root)-&gt;Rchild)&#123;</span><br><span class="line">            str[begin] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            begin += <span class="number">1</span>;</span><br><span class="line">            getParentheses(&amp;(*root)-&gt;Lchild);</span><br><span class="line">            str[begin] = <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">            begin+=<span class="number">1</span>;</span><br><span class="line">            getParentheses(&amp;(*root)-&gt;Rchild);</span><br><span class="line">            str[begin++] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业五"><a href="#作业五" class="headerlink" title="作业五"></a>作业五</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> totalPath;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getTotalPath</span><span class="params">(biTree* root,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*root)&#123;</span><br><span class="line">        totalPath += num<span class="number">-1</span>;</span><br><span class="line">        getTotalPath(&amp;(*root)-&gt;Lchild,num+<span class="number">1</span>);</span><br><span class="line">        getTotalPath(&amp;(*root)-&gt;Rchild,num+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;建二叉树二叉链表存储&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据先序，中序建立二叉树&lt;/li&gt;
&lt;li&gt;根据后续，中序建立二叉树&lt;/l</summary>
      
    
    
    
    <category term="数据结构练习" scheme="https://www.mryan.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="数据结构" scheme="https://www.mryan.cool/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C语言" scheme="https://www.mryan.cool/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="算法" scheme="https://www.mryan.cool/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构练习八</title>
    <link href="https://www.mryan.cool/2020/06/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0%E5%85%AB/"/>
    <id>https://www.mryan.cool/2020/06/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0%E5%85%AB/</id>
    <published>2020-06-09T06:34:45.000Z</published>
    <updated>2020-06-11T09:24:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol><li>荷兰国旗<ul><li>现有n个红蓝白三种不同颜色的小球，乱序排列在一起，请通过两两交换任意两个球，使得从左到右的球依次：红球、白球、蓝球。</li></ul></li><li>完美洗牌算法<ul><li>有一个长度为2n的数组{a1,a2,a3,…an,b1,b2,b3, …bn},希望“排序”后，变为{a1, b1,a2, b2,a3, b3,…an,bn}。</li></ul></li><li>买票找零问题<ul><li>在一场激烈的球赛开始之前，售票工作正在紧张地进行中。每张球票为50元。现有2n个人排队购票，其中有n个人手持50元的钞票，另外的n个人手持100元的钞票，假设开始售票时，售票处没有零钱。</li><li>问这2n个人有多少种排队方式，不至于使售票处出现找不开钱的局面呢？</li></ul></li></ol><h2 id="算法设计思想"><a href="#算法设计思想" class="headerlink" title="算法设计思想"></a>算法设计思想</h2><ol><li><p>题目是对数组的一个排序，讲数组成为三部分，分别是红白蓝，可以利用三个指针来进行数组交换。一个前指针begin，一个中指针current，一个后指针end。Current指针遍历整个数组序列：</p><ol><li>当current指针所指元素为0时，与begin指针所指的元素交换，而后begin++；</li><li>当current指针所指元素为1时，不做任何交换，而后current++；</li><li>当current指针所指元素为2时，与end指针所指的元素交换，而后current指针不动，end–；</li></ol></li><li><p>这道题是最难的一道题目了，需要用到“A Simple In-Place Algorithm for In-Shuffle”的结论了，即$2<em>n$ = $3^k-1$，说明长度为2</em>n的数组，恰好有K个圈，每个圈的头部是1，3，9，$3^k-1$。emmm，<a href="https://www.cnblogs.com/qiaoconglovelife/p/5940223.html">直接上链接，我是根据这个方法写的。</a></p><ol><li>输入数组</li><li>找到$2<em>m = 3^k - 1$,使得$3^k &lt;= 2</em>n &lt; 3^{k+1}$</li><li>把a[m+1,n+m]右移m位</li><li>对2m个数组做cycle_leader算法，数组长度为2m</li><li>对上下的数组继续使用这个算法</li><li>如果剩余的长度是2，则直接交换便可。</li></ol></li><li><p>假设有m个拿50元的，n个拿100的，总共有m+n个人，有以下三种情况</p><ol><li><p>n=0：说明都是50，则一定可以找到。即f(m,0) = 1</p></li><li><p>m &lt; n ，说明50比100的人数少，则一定找不到，即f(m,n) = 0</p></li><li><p>其他情况</p><ul><li>我们思考m+n个人排队购票，第m+n个人站在第m+n-1个人的后面，则第m+n个人的排队方式可由下列两种情况获得：<ol><li> 第m+n个人手持100元的钞票，则在他之前的m+n-1个人中有m个人手持50元的钞票，有n-1个人手持100元的钞票，此种情况共有f(m,n-1)</li><li>第m+n个人手持50元的钞票，则在他之前的m+n-1个人中有m-1个人手持50元的钞票，有n个人手持100元的钞票，此种情况共有f(m-1,n)。</li></ol></li></ul><p>不难看出递归关系</p><p>f(m,n)=f(m,n-1)+f(m-1,n)<br>初始条件：<br>当m&lt;n时，f(m,n)=0</p><p>当n=0时，f(m,n)=1</p></li></ol></li></ol><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><h3 id="作业一"><a href="#作业一" class="headerlink" title="作业一"></a>作业一</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Red 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> White 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Blue 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> test[<span class="number">5</span>][<span class="number">10</span>]=&#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; i++)&#123;</span><br><span class="line">        dutchNationalFlag(test[i] , <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">10</span> ; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,test[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dutchNationalFlag</span><span class="params">(<span class="keyword">int</span>* a ,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin , current , end;</span><br><span class="line">    begin =<span class="number">0</span>;</span><br><span class="line">    current = <span class="number">0</span>;</span><br><span class="line">    end = n<span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (current &lt;= end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[current] == White)</span><br><span class="line">            current++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[current] == Red)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[begin];</span><br><span class="line">            a[begin] = a[current];</span><br><span class="line">            a[current] = temp;</span><br><span class="line">            begin ++;</span><br><span class="line">            current++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[current];</span><br><span class="line">            a[current] = a[end];</span><br><span class="line">            a[end] = temp;</span><br><span class="line">            end --;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="作业二"><a href="#作业二" class="headerlink" title="作业二"></a>作业二</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取3的幂</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod3</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 对数组进行逆置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> begin ,<span class="keyword">int</span> end)</span></span>;</span><br><span class="line"><span class="comment">// 求m和k</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findM_k</span><span class="params">(<span class="keyword">int</span> n , <span class="keyword">int</span>* m,<span class="keyword">int</span>* k)</span></span>;</span><br><span class="line"><span class="comment">// 将数组右移</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">rightMove</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> left ,<span class="keyword">int</span> right ,<span class="keyword">int</span> inteval)</span></span>;</span><br><span class="line"><span class="comment">//在cycle里面进行数组的交换</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">cycle_leader</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> begin,<span class="keyword">int</span> length,<span class="keyword">int</span> k)</span></span>;</span><br><span class="line"><span class="comment">// 洗牌算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">shuffle</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> begin,<span class="keyword">int</span> length)</span></span>;</span><br><span class="line"><span class="comment">// 最后对数组进行2个2个的逆置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse2</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> b[] = &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> c[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *test;</span><br><span class="line">    <span class="keyword">int</span> m , k , n;</span><br><span class="line">    <span class="comment">// n = sizeof(a) / sizeof(a[0]);</span></span><br><span class="line">    <span class="comment">// findM_k( 5 , &amp;m ,&amp;k);</span></span><br><span class="line">    <span class="comment">// n =5;</span></span><br><span class="line">    <span class="comment">// test = rightMove(c , m , m+n-1,m);</span></span><br><span class="line">    test = shuffle(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c)/<span class="keyword">sizeof</span>(c[<span class="number">0</span>]));</span><br><span class="line">    reverse2(test , <span class="keyword">sizeof</span>(c)/<span class="keyword">sizeof</span>(c[<span class="number">0</span>]) );</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="keyword">sizeof</span>(c)/<span class="keyword">sizeof</span>(c[<span class="number">0</span>]) ; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,test[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">shuffle</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> begin,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length - begin &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">if</span>(length - begin == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        temp = a[begin];</span><br><span class="line">        a[begin] = a[begin+<span class="number">1</span>];</span><br><span class="line">        a[begin+<span class="number">1</span>] = temp;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m , k , n ;</span><br><span class="line">    n = (length-begin)/<span class="number">2</span>;</span><br><span class="line">    findM_k(n , &amp;m , &amp;k);</span><br><span class="line">    <span class="keyword">int</span> *test;</span><br><span class="line">    test = rightMove(a,begin+m,begin+m+n<span class="number">-1</span>,m);</span><br><span class="line">    test = cycle_leader(test,begin,begin+<span class="number">2</span>*m,k);</span><br><span class="line">    shuffle(test , begin+<span class="number">2</span>*m,length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到 2 * m = 3^k - 1 使得 3^k &lt;= 2 * n &lt; 3^(k +1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findM_k</span><span class="params">(<span class="keyword">int</span> n , <span class="keyword">int</span>* m,<span class="keyword">int</span>* k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(mod3(num) &lt; <span class="number">2</span> * n)&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    num --;</span><br><span class="line">    (*k) = num;</span><br><span class="line">    (*m) = (mod3(num) - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod3</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n  ; i++)&#123;</span><br><span class="line">        num *= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">rightMove</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> left ,<span class="keyword">int</span> right ,<span class="keyword">int</span> inteval)</span></span>&#123;</span><br><span class="line">    a = reverse(a,left,right - inteval);</span><br><span class="line"></span><br><span class="line">    a = reverse(a,right-inteval+<span class="number">1</span> , right);</span><br><span class="line"></span><br><span class="line">    a = reverse(a,left,right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> begin ,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; (end-begin+<span class="number">1</span>)/<span class="number">2</span> ; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[begin+i];</span><br><span class="line">        a[begin+i] = a[end-i];</span><br><span class="line">        a[end-i] = temp; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对数组进行变换</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">cycle_leader</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> begin,<span class="keyword">int</span> length,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mod = length - begin + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="comment">// for(int i = begin ; i&lt;length-begin ;i++)</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d\t&quot;,a[i]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; k ; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> from = mod3(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>*from%mod ; j!= from ; j = <span class="number">2</span>*j%mod)&#123;</span><br><span class="line">            temp = a[begin+j<span class="number">-1</span>];</span><br><span class="line">            a[begin+j<span class="number">-1</span>] = a[begin+from<span class="number">-1</span>];</span><br><span class="line">            a[begin+from<span class="number">-1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse2</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; length/<span class="number">2</span> ; i+=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[i+<span class="number">1</span>];</span><br><span class="line">        a[i+<span class="number">1</span>] =temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业三"><a href="#作业三" class="headerlink" title="作业三"></a>作业三</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">changeMoney</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="comment">// scanf(&quot;%d %d&quot;,&amp;m,&amp;n);</span></span><br><span class="line">    <span class="keyword">int</span> res = changeMoney(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">changeMoney</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(m &lt; n)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> changeMoney(m<span class="number">-1</span>,n) + changeMoney(m,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码总结"><a href="#代码总结" class="headerlink" title="代码总结"></a>代码总结</h2><ol><li>这次最难得就是第二题了，看那个博客费了好久好久，从用法到证明过程，都算过一遍，也算是对这类问题有了一个大致的了解</li><li>第一题也有点味道，这类思想还是可以掌握一下。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;荷兰国旗&lt;ul&gt;
&lt;li&gt;现有n个红蓝白三种不同颜色的小球，乱序排列在一起，请通过两两交换任意两个球，使得从左到右的球依次：红球</summary>
      
    
    
    
    <category term="数据结构练习" scheme="https://www.mryan.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="数据结构" scheme="https://www.mryan.cool/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C语言" scheme="https://www.mryan.cool/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="算法" scheme="https://www.mryan.cool/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构练习七</title>
    <link href="https://www.mryan.cool/2020/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0%E4%B8%83/"/>
    <id>https://www.mryan.cool/2020/06/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0%E4%B8%83/</id>
    <published>2020-06-03T09:59:25.000Z</published>
    <updated>2020-06-09T07:26:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol><li>判断两个链表是否相交</li><li>连续子数组的最大和<ul><li>输入一个整形数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O（n）</li><li>例如输入数组为（1、-2、3、10、-4、7、2、-5），和最大的子数组为（ 3、10、-4、7、2 ）,该子数组的和为18。</li></ul></li><li>数组中的逆序对<ul><li>在数组中的两个数字，如果前面的数字大于后面的数字，则这两个数字组成一个逆序对</li><li>输入一个数组，输出逆序对、并求出这个数组中出现的逆序对的总数</li><li>数组中元素{7，5，6，4}，一共有5个逆序对分别是（7,6）、（7,5）（7,4）、（6,4）、（5,4）</li></ul></li></ol><h2 id="算法设计思想"><a href="#算法设计思想" class="headerlink" title="算法设计思想"></a>算法设计思想</h2><ol><li>同时遍历两个链表到尾部，同时记录两个链表的长度。若两个链表最后的一个节点相同，则两个链表相交。有两个链表的长度后，我们就可以知道哪个链表长，设较长的链表长度为len1,短的链表长度为len2。则先让较长的链表向后移动(len1-len2)个长度。然后开始从当前位置同时遍历两个链表，当遍历到的链表的节点相同时，则这个节点就是第一个相交的节点。</li><li>当我们令curSum为当前最大子数组的和，maxSum为最后要返回的最大子数组的和当我们往后扫描时，对第j+1个元素有两种选择——要么放入前面找到的子数组，要么做为新子数组的第一个元素:<ol><li>如果currSum+当前元素a[j] &gt;= a[j]，则令currSum加上a[j]</li><li>否则currSum重新赋值，置为下一个元素，即currSum = a[j]。</li><li>(更新maxSum) 比较当前最大子数组和与最大子数组的和：</li><li>同时，当currSum &gt; maxSum，则更新maxSum = currSum</li><li>否则保持原值，不更新。</li></ol></li><li>采用递归思想，每次给函数传一个数组a，如果数组a第一个数字比之后的数字大，就形成一个逆序对，然后传递a[1:]到递归函数中。直到数组只有1个元素的时候结束。</li></ol><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><h3 id="作业一"><a href="#作业一" class="headerlink" title="作业一"></a>作业一</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ifIntersect</span><span class="params">(linkList** L1,linkList** L2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length1,length2;</span><br><span class="line">    length1 = <span class="number">1</span>;</span><br><span class="line">    length2 = <span class="number">1</span>;</span><br><span class="line">    linkNode *p;</span><br><span class="line">    linkNode *q;</span><br><span class="line">    p = (*L1)-&gt;next;</span><br><span class="line">    q = (*L2)-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next)&#123;</span><br><span class="line">        length1++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q-&gt;next)&#123;</span><br><span class="line">        length2++;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;v == p-&gt;v)&#123;</span><br><span class="line">        p = (*L1)-&gt;next;</span><br><span class="line">        q = (*L2)-&gt;next;</span><br><span class="line">        <span class="keyword">int</span> maxLength = length1 &gt; length2 ? length1 :length2;</span><br><span class="line">        <span class="comment">// P是长度长的链表，Q是长度端的链表</span></span><br><span class="line">        linkNode* temp;</span><br><span class="line">        <span class="keyword">if</span>(length1 &lt; length2)&#123;</span><br><span class="line">            temp = p;</span><br><span class="line">            p = q;</span><br><span class="line">            q = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; maxLength - length2 ; i++)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;v == q-&gt;v)&#123;</span><br><span class="line">                <span class="keyword">return</span> j;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> False;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业二"><a href="#作业二" class="headerlink" title="作业二"></a>作业二</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">-2</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">-4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">-5</span>&#125;;</span><br><span class="line">    <span class="comment">// int *b = malloc(10 * sizeof(int));</span></span><br><span class="line">    <span class="keyword">int</span> flag = findMaxSum(a,<span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;maxsum is %d\n&quot;</span>,flag);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxSum</span><span class="params">(<span class="keyword">int</span> *a ,<span class="keyword">int</span> length )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> maxsum = sum;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i&lt; length ; i++)&#123;</span><br><span class="line">        sum = (sum + a[i] &gt; a[i])? sum+a[i] : a[i];</span><br><span class="line">        maxsum = (maxsum &gt; sum) ? maxsum : sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxsum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业三"><a href="#作业三" class="headerlink" title="作业三"></a>作业三</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    findReversePair(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findReversePair</span><span class="params">(<span class="keyword">int</span>*a ,<span class="keyword">int</span> start,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(length-start &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nnumer of reverse pair is %d\n&quot;</span>,num);</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start ; i &lt; length ; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[start] &gt; a[i])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)\t&quot;</span>,a[start],a[i]);</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    findReversePair(a,start+<span class="number">1</span>,length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;判断两个链表是否相交&lt;/li&gt;
&lt;li&gt;连续子数组的最大和&lt;ul&gt;
&lt;li&gt;输入一个整形数组，数组里有正数也有负数。数组中一个或</summary>
      
    
    
    
    <category term="数据结构练习" scheme="https://www.mryan.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="数据结构" scheme="https://www.mryan.cool/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C语言" scheme="https://www.mryan.cool/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="算法" scheme="https://www.mryan.cool/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统第三讲</title>
    <link href="https://www.mryan.cool/2020/06/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E8%AE%B2/"/>
    <id>https://www.mryan.cool/2020/06/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E8%AE%B2/</id>
    <published>2020-06-03T06:01:33.000Z</published>
    <updated>2020-06-03T09:06:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同步和互斥"><a href="#同步和互斥" class="headerlink" title="同步和互斥"></a>同步和互斥</h2><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>一个结构体，由一个整型分量和一个队列指针构成，但队列指针常常被隐去，而将信号量看作整型变量。</p><p><img src="https://s1.ax1x.com/2020/06/03/taMnsS.png"></p><p><img src="https://s1.ax1x.com/2020/06/03/taQuSx.png"></p><h3 id="互斥问题"><a href="#互斥问题" class="headerlink" title="互斥问题"></a>互斥问题</h3><p>一组进程，在竞争临界时，不许同时使用。</p><h3 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h3><p><img src="https://s1.ax1x.com/2020/06/03/ta3d6x.png"></p><h4 id="消费者-生产者问题"><a href="#消费者-生产者问题" class="headerlink" title="消费者-生产者问题"></a>消费者-生产者问题</h4><p><img src="https://s1.ax1x.com/2020/06/03/ta842R.png"></p><h4 id="缓冲区无界"><a href="#缓冲区无界" class="headerlink" title="缓冲区无界"></a>缓冲区无界</h4><p><img src="https://s1.ax1x.com/2020/06/03/tawxzD.png"></p><h4 id="信号量总结"><a href="#信号量总结" class="headerlink" title="信号量总结"></a>信号量总结</h4><p><img src="https://s1.ax1x.com/2020/06/03/taDYqJ.png"></p><p><strong>PS：注意，先同步再互斥</strong></p><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p><img src="https://s1.ax1x.com/2020/06/03/taDbZj.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;同步和互斥&quot;&gt;&lt;a href=&quot;#同步和互斥&quot; class=&quot;headerlink&quot; title=&quot;同步和互斥&quot;&gt;&lt;/a&gt;同步和互斥&lt;/h2&gt;&lt;h4 id=&quot;信号量&quot;&gt;&lt;a href=&quot;#信号量&quot; class=&quot;headerlink&quot; title=&quot;信号量&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="操作系统笔记" scheme="https://www.mryan.cool/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="操作系统" scheme="https://www.mryan.cool/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="笔记" scheme="https://www.mryan.cool/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构实习6</title>
    <link href="https://www.mryan.cool/2020/06/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E4%B9%A06/"/>
    <id>https://www.mryan.cool/2020/06/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E4%B9%A06/</id>
    <published>2020-06-02T14:04:51.000Z</published>
    <updated>2020-06-03T11:54:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol><li>我们把只包含因子2,3,5的数称为丑数。求从小到大的第1500个丑数。<ul><li>例如：6,8都是丑数，但14不是丑数，因为它包含因子7.习惯上我们把1当做丑数</li><li>编写尽可能高效的算法。提示：（可以用空间换时间）</li></ul></li><li>顺时针打印矩阵<ul><li>输入一个矩阵，按照从外到里以顺时针的顺序依次打印出每一个数字，下图打印结果是1、2、3、4、8、12、16、15、14、13、9、5、6、7、11、10</li><li><img src="https://s1.ax1x.com/2020/06/02/tN2x74.png"></li></ul></li><li>设二维数组B$[$0..m-1$]$[0..n-1]的数据在行、列方向上都按从小到大的顺序有序，且x在B中存在。试设计一个算法，找出x在B数组中的位置i,j。要求比较的次数不超过m+n.</li></ol><h2 id="算法设计思路"><a href="#算法设计思路" class="headerlink" title="算法设计思路"></a>算法设计思路</h2><ol><li>丑数都是由因子2，3，5组成的，所以我们可以根据现有的丑数来乘2，3，5来得到。我们可以创建由1500个元素的数组，顺序排列，从头遍历，寻找有一个数字乘以2刚好大于数组的最后一个数字，寻找寻找有一个数字乘以3刚好大于数组的最后一个数字，寻找有一个数字乘以5刚好大于数组的最后一个数字，做好标记。在插入数据的时候，将这三个数比较，取最小值插入数组的末尾。</li><li>网上的教程都是分类讨论，但其实这题我们可以通过固定四个角来规定要打印的数字。定位左上角，右上角，左下角，右下角。根据这四个角的位置来进行遍历。遍历一遍后，将四个角搜索。知道左上角和左下角重合。</li><li>因为二维数组是有序的，我们可以先通过遍历行确定行，再通过遍历列来确定列。比较次数不超过m+n次。</li></ol><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><h3 id="作业一"><a href="#作业一" class="headerlink" title="作业一"></a>作业一</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b , <span class="keyword">int</span> c)</span></span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">1500</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index5 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; <span class="number">1500</span> ; i++)&#123;</span><br><span class="line">        num[i] = Min(num[index2]*<span class="number">2</span> , num[index3] * <span class="number">3</span> , num[index5]*<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">while</span>(num[index2] * <span class="number">2</span> &lt;= num[i])</span><br><span class="line">            index2++;</span><br><span class="line">        <span class="keyword">while</span>(num[index3] * <span class="number">3</span> &lt;= num[i])</span><br><span class="line">            index3++;</span><br><span class="line">        <span class="keyword">while</span>(num[index5] * <span class="number">5</span> &lt;= num[i])</span><br><span class="line">            index5++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result is %d&quot;</span>,num[<span class="number">1499</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b , <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = a &lt; b ? a:b;</span><br><span class="line">    <span class="keyword">return</span> min &lt; c ? min : c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业二"><a href="#作业二" class="headerlink" title="作业二"></a>作业二</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> rows,<span class="keyword">int</span> cols)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    test(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> rows,<span class="keyword">int</span> cols)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>** num = <span class="built_in">malloc</span>(rows * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows ; i++)</span><br><span class="line">        num[i] = <span class="built_in">malloc</span>(cols * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows ; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; cols ; j++)&#123;</span><br><span class="line">            num[i][j] = i * cols + j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; cols ; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,num[i][j]);</span><br><span class="line">            <span class="comment">// printf(&quot;%p--%d&quot;,&amp;num[i][j],num[i][j]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftTop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rightTop = cols - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> leftBottom = (rows<span class="number">-1</span>) * cols;</span><br><span class="line">    <span class="keyword">int</span> rightBottem = rows * cols <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 左上角的左下角重合,，说明只有一行</span></span><br><span class="line">    <span class="keyword">if</span> (leftTop == leftBottom)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; cols ; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,num[<span class="number">0</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( leftTop != leftBottom)&#123;</span><br><span class="line">            <span class="comment">// 从左向右打印</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =  leftTop % cols ; j &lt;= rightBottem % cols ; j++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,num[leftTop / rows][j]);</span><br><span class="line">            <span class="comment">// 从上向下打印</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = rightTop/cols + <span class="number">1</span> ;i&lt;= rightBottem / cols ; i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,num[i][rightBottem % cols]);</span><br><span class="line">            <span class="comment">// 从下到左打印</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = rightBottem % cols - <span class="number">1</span> ; j &gt;= <span class="number">0</span> ; j --)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,num[rightBottem / cols][j]);</span><br><span class="line">            <span class="comment">//从左向上打印 </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = leftBottom/cols - <span class="number">1</span> ; i &gt; leftTop / cols ; i--)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,num[i][leftTop%cols]);</span><br><span class="line">            <span class="comment">// 改变四个角的位置</span></span><br><span class="line">            leftTop += (cols +<span class="number">1</span>);</span><br><span class="line">            rightTop += (cols - <span class="number">1</span>);</span><br><span class="line">            leftBottom -= (cols - <span class="number">1</span>);</span><br><span class="line">            rightBottem -= (cols + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = leftTop % cols ; j &lt;= rightTop % cols ; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,num[leftTop/cols][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows;i++)</span><br><span class="line">        <span class="built_in">free</span>(num[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业三"><a href="#作业三" class="headerlink" title="作业三"></a>作业三</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">23</span>;</span><br><span class="line">    test(<span class="number">5</span>,<span class="number">5</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> rows,<span class="keyword">int</span> cols , <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>** num = <span class="built_in">malloc</span>(rows * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows ; i++)</span><br><span class="line">        num[i] = <span class="built_in">malloc</span>(cols * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows ; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; cols ; j++)&#123;</span><br><span class="line">            num[i][j] = i * cols + j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; rows ; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; cols ; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,num[i][j]);</span><br><span class="line">            <span class="comment">// printf(&quot;%p--%d&quot;,&amp;num[i][j],num[i][j]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">while</span>(num[i][<span class="number">0</span>] &lt;= target &amp;&amp; i+<span class="number">1</span> &lt; rows)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i][<span class="number">0</span>] == target)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)&quot;</span>,i,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; cols &amp;&amp; num[i][j] &lt;= target ; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num[i][j] == target)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)\n&quot;</span>,i,j);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;我们把只包含因子2,3,5的数称为丑数。求从小到大的第1500个丑数。&lt;ul&gt;
&lt;li&gt;例如：6,8都是丑数，但14不是丑数，因</summary>
      
    
    
    
    <category term="数据结构练习" scheme="https://www.mryan.cool/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="数据结构" scheme="https://www.mryan.cool/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="C语言" scheme="https://www.mryan.cool/tags/C%E8%AF%AD%E8%A8%80/"/>
    
    <category term="算法" scheme="https://www.mryan.cool/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统第二讲</title>
    <link href="https://www.mryan.cool/2020/05/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E8%AE%B2/"/>
    <id>https://www.mryan.cool/2020/05/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E8%AE%B2/</id>
    <published>2020-05-27T07:09:35.000Z</published>
    <updated>2020-06-03T06:04:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一讲"><a href="#第一讲" class="headerlink" title="第一讲"></a>第一讲</h1><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p><img src="https://s1.ax1x.com/2020/05/27/tA8c2F.png"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">管程：临界资源管理的一种机制。</span><br><span class="line">并发：宏观上的并行，微观上的串行</span><br><span class="line">PCB：存放进程信息的结构</span><br><span class="line">临界资源：不能被多个进程同时使用的资源（打印机）</span><br><span class="line">临界区：使用临界资源的代码</span><br></pre></td></tr></table></figure><h3 id="进程状态和进程控制"><a href="#进程状态和进程控制" class="headerlink" title="进程状态和进程控制"></a>进程状态和进程控制</h3><p>进程：一个并发程序在一个处理机上的执行过程</p><p>进程三大块：code,data,PCB</p><p>程序两部分:code,data</p><pre><code>1. 动态性 2. 并发性 3. 独立性 4. 制约性 5. 结构性</code></pre><h4 id="为什么要引入进程概念："><a href="#为什么要引入进程概念：" class="headerlink" title="为什么要引入进程概念："></a>为什么要引入进程概念：</h4><p>​    刻画并发程序的特性，便于管理多道程序，管理处理机等资源</p><p><img src="https://s1.ax1x.com/2020/05/27/tAND9P.png"></p><h4 id="五状态进程"><a href="#五状态进程" class="headerlink" title="五状态进程"></a>五状态进程</h4><p><img src="https://s1.ax1x.com/2020/05/27/tAapin.png"></p><h4 id="七状态进程"><a href="#七状态进程" class="headerlink" title="七状态进程"></a>七状态进程</h4><p>挂起：为了减少内存的压力</p><p><img src="C:\Users\Administrator.DESKTOP-4CPBO21\AppData\Roaming\Typora\typora-user-images\image-20200527154220850.png"></p><h3 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h3><p>将管理一个进程需要的所有信息存放在<strong>PCB</strong>中。</p><h4 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h4><ol><li>创建</li><li>调度</li><li>撤销</li><li>阻塞</li><li>唤醒</li><li>挂机</li><li>激活</li></ol><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p>剥夺方/非剥夺式调度</p><p>调度算法评价</p><ol><li>吞吐率</li><li>周转时间</li><li>平均周转时间</li><li>带权平均周转时间</li><li>响应时间</li></ol><p>常见的调度算法</p><ol><li>FCFS</li><li>RR（轮转）</li><li>SJF（短者优先）</li><li>HPN（优先级高者优先）</li><li>HRRN（相应比高者优先）</li><li>多队列反馈式调度</li></ol><h4 id="进程死锁"><a href="#进程死锁" class="headerlink" title="进程死锁"></a>进程死锁</h4><p><img src="https://s1.ax1x.com/2020/05/27/tAs5CQ.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一讲&quot;&gt;&lt;a href=&quot;#第一讲&quot; class=&quot;headerlink&quot; title=&quot;第一讲&quot;&gt;&lt;/a&gt;第一讲&lt;/h1&gt;&lt;h2 id=&quot;进程管理&quot;&gt;&lt;a href=&quot;#进程管理&quot; class=&quot;headerlink&quot; title=&quot;进程管理&quot;&gt;&lt;/a&gt;进程管</summary>
      
    
    
    
    <category term="操作系统笔记" scheme="https://www.mryan.cool/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="操作系统" scheme="https://www.mryan.cool/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="笔记" scheme="https://www.mryan.cool/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
